## 1. SOLID의 원칙: 프론트엔드 개발의 견고한 기반 다지기

SOLID 원칙은 특정 언어나 프레임워크에 종속되 기술이 아니다.
복잡성이 높은 현대 프론트엔드 애플리케이션의 유지보수성, 유연성, 확장성을 보장하는 보편적인 설계 철학
5가지를 통해 우리는 더 견도한 아키텍처를 만들 수있음

- S: 단일 책임 원칙 (Single Responsibility Principle)
- O: 개방-폐쇄 원칙 (Open/Closed Principle)
- L: 리스코프 치환 원칙 (Liskov Substitution Principle)
- I: 인터페이스 분리 원칙 (Interface Segregation Principle)
- D: 의존관계 역전 원칙 (Dependency Inversion Principle)

## 2. 단일 책임원칙: 하나의 컴포넌트는 하나의 기능만

재사용 간으하고 테스트하기 쉬운 UI 컴포넌트를 만드는 첫 걸음임

하나의 컴포넌트는 변경되어야 할 단 하나의 이유만을 가져야한다는의미

- Before: 원칙을 위배한 경우
  - 거대한 UserPRofile컴포넌트가 있다고 가정
  - 이 컴포넌트는 서버API호출하는 데이터 페칭
  - 데이터를 UI에 렌덜이하는 로직 2개를 가짐
  - API명세가 변경되어도 UserProfile을 변경해야하고
  - UI디자인이 변경되어도 같ㅇ느 컴포넌트를 수정해야함
  - 변경의 이유ㅜ가 2가지 이상이므로 SRP을 위반한 것
- After: 원칙을 적용한 경우
  - 컴포넌트 책임을 분리해보겠음
  - 데이터 페칭과 상태 관리로직은 useUserData 커스텀 훅으로 분리
  - UserProfileView컴포넌트는 오직 UI렌더링에만 책임짐
  - useUserData:
    - 데이터 로딩, 성공, 실패 관리
    - API통신을 전담하는 상태 및 사이드 이펙트 관ㄹ리로직
  - UserProfileView:
    - useUserData훅으로 데이터를 propㄴ로 전달받아
    - UI를 렌덜이하는ㄷ ㅔ만 집주하는 UI 렌덜이 담당 컴포넌트
  - 이렇게 책임을 분리하면 useUserData훅은 다른 컴포넌트에서도 재상요가능하고
  - UserProfileView는 UI테스트가 훨씬 용이해짐
  - 가독성과 유지보수성이 향상되는것은 덤임

## 3. 개방 폐쇄 원칙 - 확장은 쉽게 변경은 어렵게

코드의 생존력을 높여줌
새로운 기능으 ㄹ추가할 때마다 기존 코드르 수정해야한다면, 예상치못한 버그가 밠뱅할 위험이 커짐
OCP는 이 위험을 최소화하는것이 목표

개방 폐쇄 원칙이란, 소프트웨어 개체는 확장에는 열려있지만, 수정에는 닫혀있어야한다는 의미

- Before: 원칙을 위배한 경우
  - ItemList컴포넌트가 아이템의 타입에 따라 if,else 또는 switch문으로 분기하여 각기 다른 컴포넌트를 렌더링한다고 가정해보자.
  - 만야 광고아이템이라는 새로운 유형이 추가된다면?
  - 우리는 ItemList컴포넌트를 직접 열어, switch 문을 추가해야함
  - 이는 수정에는 닫혀있어야한다느 원칙을 정면으로 위반함
- After: 원칙을 적용한 경우
  - 이 구조를 컴포넌트 조합 패턴을 활용해 개선 가능
  - 예를 들어 공통적인 프레임 역할을 하는 ItemContainer컴포넌트를 만들고
  - 그 안에 렌덜이 될 특정 아이템 컴포너트를 children prop으로 전달받도록 설계
  - 이 구조엣서는 광고 아이템이 추가되더라도 InteContainer나 기존 로직을 전혀 수정할 필요가 없음
  - 새로운 AdItem컴포넌ㅌ트를 만들어 InteContainer안에 넣어주기만 하면 됨
  - 이처럼 홪강에 열려있고 수조정에는 닫혀있는 구조 가능함

## 4. L, I, D: 더 높은 수준의 추상화를 향하여

리스코프 치환, 인터페이스 분리, 의존 관계 역전 원칙은 '동맹 규약'이나 '고위 마법'과 같음
이 세원칙은 컴포넌트와 모듈간의 결합도를 낮추고, 애플리케이션 전체의 아키텍처를 견고하게 만듬

### 4.1 리스코프 치환 원칙

- 정의:
  - 프론트엔드 관점에서 LSP는
  - 부모 컴포넌트 자리에 자식 컴포넌트를 대신 사용하더라도 시스템이 문제 없이 동작해야한다. 고 해석 가능
  - 예를 들어
  - 기본 Button컴포넌트를 확장한 PrimaryButton이 있다고 가정
  - 만약 PrimaryButton이 onClick 핸들러의 기본 동작을 변경하여(가령, 내부적으로 확인창을 띄우도록 수정)
  - Button을 사용할때와 다르게 동작한다면 LSP를 위반한것
  - 이는 예측 불가능한 버그로 이어질 수 있으므로, 자식 컴포넌트는 부모의 계약을 반드시 준수해야함

### 4.2 인터페이스 분리 원칙

- 정의:
  - ISP는 컴포넌트느 자신이 사용하지 않는 props에 의존해서는 안된다.
  - 거대한 user객체 하나를 여러 컴퍼넌트에 통쨰로 넘겨주는 상황을 생각해ㅗㅂ자.
  - Avatar 컴포넌트는 user.profileImageUrl만 필요하고
  - UserName 컴포넌트는 user.name만 필요한데도 불필요하게 모든 사용자 정보를 전달받게됨
  - 이는 user객체의 다른 속성이 변경될 때마다React.memo로 감싸진 컴포넌트에서 불필요할 리렌더링ㅇ을 유발할 수 있음
  - ISP에 따르면 컴포너특 깊요로하는 최소한의 props만 받로고하여 의존성을 줄이고 성능최적화 가능

### 4.3 의존 관계 역전 원칙

- 정의
  - 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안되며
  - 둘 모두 추상화에 의존해야한다.
  - 예를 들어, 컴포넌트가 API 통신 라이브러리인 axios에 직접 의존하다면,
  - 테스트시 실제 네트워크 요청이 발생하여 테스트가 느려지고 불안정해짐
  - DIP를 적용하면
  - 컴포넌트는 axios가 아닌 추상화된 apiService라는 인터페이스에 의존하게 됨
  - 실제 프로덕션 코드에서는 axios를 사용하는 apiService 구현체를 주입하고
  - 테스트 환경에서는 가짜 데이터를 반환하는 mockApiService를 주입할 ㅅ ㅜ이있음
  - 이런한 설계는 테스트 용이성을 극저으로 향상시켜 안정적인 소프트웨어를 마드느데 결정적인 이점을 제공

## 5. 프론트엔드에게 SOLID는 필요한가요?

그렇다 임
반드시 지켜야할 엄격한 규칙이라기보다
끊임없이 복잡해지는 현대 프론트엔드개발의 난이도를 관리하고 길을 잃지 ㅇ낳게 해주는 유용한 지도이자 설계 철학임

잘 만든 소프트웨어 역시 견고한 구조와 명확하게 분리된 책임
그리고 새로운 사건에 유연하게 대처하는 ㅡㅇ력을 갖춰야함

실용적인 조언

- 처음부터 모든 원칙을 완벽하게 적용하려하지마라
- 다음 번에 새로운 컴포넌트를 만들때
- 이 컴포넌트가 너무 많은 일을 하고있지는 않으까
- 를 의식적으로 한번 떠올려보자.
- 이런 작은 노력과 고민이 쌓여 안정적이고 확장 가능한 사용자 경험을 만드느 튼튼한 기반외 될것임
