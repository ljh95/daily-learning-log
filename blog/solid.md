## 1. 원칙은 이론이 아닌 실무에서 태어났다.

많은 개발자가 설꼐 원칙은 추상적인 이론에서 출발했다고 오해함
하지만 실제는 반대임
SOLID와 같은 원칙들은 어떻게 하면 이 고통을 반복하지 ㅇ낳을 수 있을까 하는 고민에서 도출된것

## 2. 가장 중요한 원칙 SRP는 사실 사람에 관한 이야기다.

단일 책임 원칙 을 하나의 함수는 하나의 동작만 해야한다는 기술적 지침으로만 이해하면 핵심을 놏기시 쉬움
SRP의 더 깊은 의미는
하나의 모듈은 오직 하나의 액터에 대해서만 책임져야한다 는 것

여기서 액터란 변경을 요청하는 사요자 또는 이해관꼐자 그룹을 의미하(최근에 본 드미트리 원칙 이랑 유사한가..??!)

결국 '변경ㅇ의 이유'는 코드 밖의 사람에게서 나옴
재무팀과 인사팀이 모두 '급여 계산'이라는 기능을 사용하더라도
두 팀의 요구사항은 각기 다른 이유로, 다른 시점에 변경될 수 있음
두 액터를 위해 하나의 거대한 calculatePay()함수를 만들면 2 요구사항이 코드를 망가뜨릴 수 있음

이것이 SRP가 응집성과 연결되는 지점임
응집성이란 단일 액터가 책임지는 코드를 함꼐 묶어주는힘

떄로는 재무팀과 인사팀의 로직이 비슷해 보인다고 해서 무조건 하나로 합ㅊ는 것이 최선이 아닐 수 있음
각기 다른 액터를 윟나 것이라면, 코드가 일부 중복되더라도, 의도적인 중복을 통해 분리하는것이 장기적으로 훨씬 선명한 선택일 수 있음

- 내가 다이어그램이라는 같은 개념을 이용하지만
- dfd, logical, physical은 다르게 한 이유가 될 수 있을까?

이 원칙은 결국 조직의 소통 구조와 맞닿앙 있습니다.
시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조와 설계를 만들어 낼 것이다.

만약 ㅅ당신의 코드가 SRPf를 위한하며 비대해지고 있다면 그것은 기술적 문제를 넘어 개발팀과 기획팀, 혹은 현업 부서간의 소통에 문제강 있다는 신호일 수 있다.
SRP는 기을 넘어 조직과 사람을 보게하는 창

## 3. 프론트엔드라고 예외는 아니다.

- UI는 너무 자주 바뀌엇 구조를 잡는건 오버 엔지니어링이다.
- 프레임워크가 있는데 굳이 그런 원칙까지 신경 쓸 필요 없다.
- 객체 지향원칙은 백엔드에나 어울린다.

하지만 이런 주장은 떄로 '깊이의 부족을 합리화'하려는 태도일 수 있음
물론 모든 상황에 같은 구조를 적용하는것으 정답이 아님
하지만 구조에 대한 고민 없이 작성된 코드가 어떤 결과를 ㅏㄴㅎ는지 우리는 알고있음

"상품에 혜택이 하나 추가되었을 때, 우리 프로젝트의 어디에 있는 어떤 코드를 수정하면 되나요? 새로운 타임의 고객이 추가되었을 때는요?"

이 질문에 망설여진다면, 우리에겐 구조적인 고민이 필요하다는 뜻

SOLID 원칙에 등장하는 클래스 떄문에 객체지향에만 국한된다고 생각할 필여 없음
클래스는 단순히 함수와 데이터를 결합한 집합, 즉 프론트엔드의 컴포너트아 모듈로 치화해서 이해해도 무방함

## 4. 진짜 목적은 '변경'에 유연하게 대처하는 것이다

개방 폐쇄 원칙과 의존성 역전 원칙이 이 목표를 명확히 보여줌

### 개방 폐쇄 원칙(OCP): 수정 없이 기능을 확장하는 마법

OCP의 핵심은 기존 코드를 수정하지 안혹 새로운 코드ㅡㄹ ㄹ추가하는 방식으로 시스템의 행위를 변경하는 것
React의 컴파운트 컴포넌트패턴이 완벽한 예시임

Before: OCP를 위반하는 Card 컴포넌트 새로운 기능(댓글, 좋아요)이 추가도리 때마다 Card 컴포넌트의 내부를 직접 수정해야함

// Card.jsx
function Card({ title, content, comments, onLike }) {
return (
<div className="card">
<h2>{title}</h2>
<p>{content}</p>
{/_ 댓글 기능이 추가되면 Card 컴포넌트 수정 _/}
{comments && <div className="comments">{comments.join(', ')}</div>}
{/_ 좋아요 기능이 추가되면 또 Card 컴포넌트 수정 _/}
{onLike && <button onClick={onLike}>Like</button>}
</div>
);
}

After: OCP를 준수하는 Card 컴포넌트는 새로운 기능을 하위 컴포넌트로 만들어 추가하면 그만임, 기존 Card를 건들리 필요가 없음

// 사용 예시
<Card>
<Card.Title>OCP 예시</Card.Title>
<Card.Content>확장에는 열려있고, 수정에는 닫혀있습니다.</Card.Content>
{/_ 새로운 댓글 기능을 '추가' _/}
<Card.Comments data={commentData} />
{/_ 새로운 좋아요 기능을 '추가' _/}
<Card.LikeButton onClick={handleLike} />
</Card>

이것이 바로 '확장에는 열려있고 수정에는 닫혀있다.'는 OCP의 진정한 의미

### 의존성 역전 원칙(DIP): 구체성 대신 추상성에 의존하기

DIP의 핵심은 "구체적인 구현이 아닌 추상화에 의존"하여 변경의 영향을 최소화하는것입니다.
간단히 말해, '세부 사항을 직접 만들거나 가져오지 말고, 외부에서 약속된 형태로 주입받아 사용하라'뜻

Before: DIP를 위반하는 데이터 페칭 컴포넌트 UserProfile 컴포넌트가 axios 라는 구체적이 라이브러리와 특정 API 경로에 의존하고 있음
fetch로 바꾸거나 API 경ㄹ로는 바꾸게 되면 이 컴포너느 코드르 직접 수정해야함

// UserProfile.jsx
import axios from 'axios';

function UserProfile({ userId }) {
const [user, setUser] = useState(null);

useEffect(() => {
// 'axios'와 '/api/v1/users/' 라는 구체적인 구현에 의존
axios.get(`/api/v1/users/${userId}`).then(res => setUser(res.data));
}, [userId]);

// ...
}

After: DIP를 준수하는 데이터 페칭 컴포넌트 UserProfile은 이제 fetchUser라는 함수를 그냥 props로 받음, 이제 axios를 쓰는지 다른걸 쓰는지 신경쓰지 않음, 약속된 형태 ((id) => Promise<User>)이기만 하면 됨

// UserProfile.jsx
function UserProfile({ userId, fetchUser }) {
const [user, setUser] = useState(null);

useEffect(() => {
// '어떻게' 가져오는지는 모르지만, '가져온다'는 추상적인 행위에만 의존
fetchUser(userId).then(data => setUser(data));
}, [userId, fetchUser]);

// ...
}

// 사용 부
import { fetchUserWithAxios } from './api';
<UserProfile userId="123" fetchUser={fetchUserWithAxios} />

DIP를 통해 우리의 컴포넌트는 훨씬 유연하고 테스트하기 쉬워졌음
여기서 주목할 점은 DIP를 잘 따르면 OCP도 자연스럽게 지켜진다는것

이 원칙들은 OCP, DIP는 집(안정적인 핵심 로직)을 허물지 않으면서도, 새로운 기능을 마음껏 바꿀 수 있게 해주는 실용적인 설계 기술임

## 결론: 원칙을 넘어 생각의 도구로

원칙은 실무에서 태어났고
사실 사람과 조직에 관한 이야기이며
프론트엔드로 충분히 적용가능하고
궁극적인 목표는 예측 불가능한 변경에 현명하게 대처하는것이라는 사실을 알게 됨
