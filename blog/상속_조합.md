## 1. 부모의 작은 변확 ㅏ작식을 망가뜨린다.: 취약한 기반 클래스 문제

부모 클래스의 작은 변경이 예기치 않계 모든 자식 클래스에 영향을 미쳐 오작동을 일으키는 현상

Lotto클래스와 이를 상속받은 WinningLotto가 있다고하자
로쪼 번호 배열을 가지는 Lotto가 이쏙, 당첨 로또를 표현하기 위해 이 클래스를 상속바아 보너스 번호마 추가한 WinningLotto클래스를 만들었다고 ㄱ자ㅓㅇ해보자.

```java
// 부모 클래스
public class Lotto {
    private int[] numbers;
    // ...
}

// Lotto를 상속받은 자식 클래스
public class WinningLotto extends Lotto {
    private int bonusNumber;
    // ...
}
```

여기까진 좋다.
그런데ㅐ Lotto클래스의 numbers필드를 배열 int[]에서 리스트 로 변경하라는 피드백을 주었음
아마 성능을 개ㅓㅅㄴ하거 컬렉션 프레임워크의 풍부한 API를 위한 제한임

피드백에 따라Lotto내부 구현을 변경함

```java
// Lotto 클래스 내부 구현 변경
public class Lotto {
    private List<Integer> numbers; // 배열에서 리스트로 변경
    // ...
}
```

우리는 Lotto클래스만 수정해#찌만, WinnignLotto클래스에서 컴파일 에러가 남
이 문제의 근본적인 원ㅇ니은 자식 크래스가 부모 클래스의 '구현'에 강하게 의존하기 떄문
상속은 부모의 publick메서드 뿐만 아니라 protected 필드나 메서드까지 접근할 ㅜㅅ 이게 하여
부모 클래스의 캡ㅅㄹ화를 깨뜰미
이러철 ㅁ상속은 부모 클래스와 가아헤 의종하고 부모 클래스의 캡슐화를 해칙 결합도가 높아짐
그래서 부모클래스의 구현을 변경하면, 많은 자식 클래스르 모두 변경해야함

---

## 2. 원하지 않는 기능까지 상속받는 비극: 자바 Stack클래스의 사례

부모 클래스의 모든 public 메서드가 자식 클래스에 강제로 노출된다는점
이것이 자식 크래스의 핵심 규칙을 무너뜨리는 원이이 됨
Java ApI의 Stack크래스가 예시

Stack은 Vector을 상속함
Stack자료구조의 핵심 규칙은 마지막에 넣은 데이터가 가장 먼저 나오는 후입선추임
데이터를 넣을떄는 push, 뺄때는 pop을 해야함

```java
Stack<String> stack = new Stack<>();
stack.push("첫 번째");
stack.push("두 번째");
stack.push("세 번째");

String element = stack.pop(); // "세 번째"가 나와야 함
```

하지만 Stack부모인 Vector로부터 원치않ㅇ느 add메서드까지 물려 받음
이 메서드를 사용하면 Stack의 중간에 데이털를 상ㅂ입할 수 있어, LIFO규칙이 꺠지게됨

```java
Stack<String> stack = new Stack<>();
stack.add("하나");
stack.add("둘");
stack.add(0, "중간에 삽입"); // Stack의 규칙 위반!

System.out.println(stack.pop()); // "둘"이 출력됨
```

Vector의 add메서드가 public이기에 필요없거나 해가되는 메서드일지라도 어쩔 수 없게 외부에 노출됨
이는 클래스가 지켜야할 자체적인 규칙과 일관성을 유지하기 어렵게 만드는 문제임

---

## 3. 상속의 내안, 더 안전하고 유연한 '조합'

앞의 두 문제를 해결할 강력한 대안이 바로 조합임
조합은 전체를 표현하는 클래스가 부분을 표현하는 객체로 호함되여 코드르 재사용하는 방법

방법은 간단함
상속대신 재사용하려는 클래스의 인스턴스를 새로운 클래승의 private필드로 참조하고,
그 인스턴스의 메서드를 호출하여 필요한 기능을 구현하는 방식

### 1. WinningLotto문제 해결

```java
public class WinningLotto {
    private final Lotto lotto; // 상속 대신 필드로 포함 (조합)
    private final int bonusNumber;

    // ... Lotto의 기능이 필요하면 lotto 필드의 메서드를 호출
}

```

이렇게 하면 WinningLotto는 Lotto의 내부 구현을 전혀 알 필요 없음
Lotto의 퍼블릭인터페이스에만 의존하게 됨
따라서 내부 구현이 변경되도 영향받ㄷ지 않음

### 2. Stack의 문제 해결

```java
import java.util.EmptyStackException;
import java.util.Vector;

public class MyStack<E> {
    private Vector<E> vector = new Vector<>(); // 상속 대신 필드로 포함 (조합)

    public E push(E item) {
        vector.add(item);
        return item;
    }

    public E pop() {
        if (vector.isEmpty()) {
            throw new EmptyStackException();
        }
        int lastIndex = vector.size() - 1;
        E obj = vector.get(lastIndex);
        vector.remove(lastIndex);
        return obj;
    }

    // add(index, element) 같은 불필요한 메서드는 외부에 노출하지 않음
}

```

---

## 4. 그렇다면 상속은 언제 사용?: Is-a관계와 다형성

상속의 목적은 2가지로 나눌 수 있음

1. 서브 클래싱:
   1. 단순히 코드 재사용을 위해 상속을 사용하는 경우,
   2. 대부분의 문제가 여기서 출발
2. 서브 타이핑
   1. 다형적인 객체 계층 구조를 만들기 위해 상속으 사용
   2. 이것이 상속이 권장하는 올바른 사용법

가장 큰 차이는 "부모 클래스의 행동과 자식 클래스의 행동이 서로 호환되는지"임
올바른 상속, 서브 타이핑을 적용하기 위해서는 상속을 고려하기 전에 스스로에게 다음 2가지 질문을 던져야함

- 두 객체는 Is-A관계인가?
- 클라이언트 관점에서 두 객체가 동ㅇ리하게 행동할 것이라고 기대되는가?
  Stack과 Vector의 경우 클라이언트가 두 객체에 기대하는 행동은 명백히 다름
  Vector는 우리가 자주 사용하는 ArrayList처럼 동작하기 기대하고, Stack은 Lifo규칙에 돟ㅇ작하기 희망함

---

## 결론: 재사용이 필요하면 조합, 다형성이 필요한 상속

상속보다는 조합을 우선하라는 객체지향의 오랜 격언

코드를 재사용하고ㅓ 중복을 없애는것이 목적이라면 상속으로 인한 강한 결합과 부작용을 감수하는대신 조합을 사요하는것이 더 안전함
반면 클라이언트 입장에서 동일하게 행동하는 여러 타입의 객체들을 하나의 타입으로 묶어 다루고 싶을때,
즉 다형성이 필요할 떄ㅑ 상속을 고려할 수 있음
이 경우 is-a관계와 행동의 호환성을 만족해야함
