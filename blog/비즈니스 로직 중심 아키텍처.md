# React 애플리케이셔의 새로운 설계 패러다아ㅣㅁ: 비즈니스 로직 중시 아키텍처

## 1. React다운 코드에 대한 비판적 고찰

소프트웨어 개발 커뮤니티에서 통용되는 관례를 이해하고 때로는 의문을 제기하는것은 전략적으로 매우 중요함
흔히 'React다운 코드'라ㅗ 불리는 이러하 ㄴ관례들은 프로젝트 초기 방향을 잡는데 유용한 기준선을 제공하지만,
비판적인 사고 없이 이를 맹목적으로 적요하는것은 올바른 방향이, 아님

'React 다운 코드'란
일반적으로 JSX문법을 적극적으로 활용하여 선언적으로 뷰를 구성하고
관련 로직을 커스텀 훅으로 묶어내며
Compound Components나 HOC와 같ㅇ느 일반적인 컴포넌트 디자인 패턴을 적요하는ㄱ방식을 의미함
이러한 스타일은 상태 관리를 이ㅜ해 useState를 API호출과 같으 부슐효과를 다루기 위해 useEffect를 사용하느것이 당옇나 고나행으로 여겨짐

하지만 특정 기수의 숙어와 패턴을 깊이 이해하고 따르는것은 중요하짐나 그 본질을 간과해서 ㄴ안됨

진까 기준은 어떤 언어의 키워드르 썼느느냐ㅐ가아니라 어떤 스타일을 따르고 어뚠 숙어를 사용했는가이다.

커뮤니티의 class문법에 대한 거부감을 사례로 이 묹데를 더 깊이 파헬쳐보겠습니다.
React개발자들이 class 사용을 기피하는 데에는 3가지 이유가 있습니다.

- 패러다임 불일치:
  - React는 함수형 패러다임위에 세워졌기에 객체지햐으이 class문법이 어울리지 않느다는 인식
- 역사적 배경:
  - 과거 Class형 컴포너트에서 함수형 컴포넌트와 Hooks기반 스타일로 전환된 역사
- 기술적 복잡성:
  - JavaScript의 this 문법이 가진 비일관성에서 오는 거부감.

하지만
패러다임 불일치는 코드 스타일 상의 선호도 문이고, 역사전 배경은 class형 컴포넌트의 비판일 뿐, class본질적인 문제가 아님,
this의 복잡성 역시 중의가 필요한 부분이지 사용자체를 금기시할 이유는 되지 않음

class를 선호하지 않을 수는 있지만, 그걳이 캡슐화와같ㅇ느 강력한 소프트웨어 설계 원치까지 버려야함을 의미하지는 않음

---

## 2. React의 역할 재정: UI 렌더러로서의 본질

React 애플리케이션에서 가장 흔하게 발생하는 아킨텍처실수는 React 라이브러리에 본래 설계되지 않은 과동하 ㄴ책임을 부여하는 것임
이 문제를 해결하기 위해 우리는 Reawct의 핵심 기능을 명화힉 재정의하고 그 역할의 경계를 설정해야함

React의 가장 강력한 본질은 바로 탁월한 UI렌더러라는점
소스 컨텍스트에서 "신이 내린 발명품"이라고 표현됨 JSX는 개발자가 '무엇이'그려져야하느지 선언적으로 기술할 수 있게 해줌
그러면 '언제', '어떻게' 화면을 업데이트할지에 대한 복잡한 명령형 로직ㅇ느React가 전적으로 책임짐
이것이 React가 제공하느 ㄴ핵심 가치임

문제는 우리가 이 강력한 도구를 마치 ㅇ신처럼 떠받들기 시작하면서 시작됨
React가 제공하느 편의성에 기대 상태과린, 데이터 ㅍ페칭, 전역 상태 동기화 등 온갖 종유의 비즈니스 로직을 Reawct컴포너트와 훅 내부에 모두 넣기시작함

ㅂ;즈니르 로직 처리에 React의 기본 요ㅕ소를 남용할 떄 방생하는 아키텍처 비용은 상당함

- useState와 상태 업데이트:
  - React의 상태 업데이트는 근볹거으로 액션입니다.
  - 이 액션은 React내부에서 비동기적으로 처리되면, 개발자가 그 과정을 직접 추적하거나 제어할 수 없읍니다.
  - 우리는 상태 업데이트를 부메랑처럼 던져놓고 얌전히 useEffect에 들어안자 업데이트가 돌아오기를 바라는 수밖에 없습니다.
  - 이는 로직의 프름을 파악하기 어렵게 만들고 예측 불가능성을 높입니다.
- useEffect와 부수효과
  - useEffect는 의존성 배열이 한두개일때는 명료하지만, 배열이 보작ㅂ해질 수록 원하는 시점과 빈도록 부수효과를 정화히 제어하기가 매우 까다로워집니다.
  - 이는 버그의 온상이 되기 쉽습니다.
- 시간 의존성의 도입 SICP(Strcture and Interpretation of Computer Programs)
  - 순수한 계산은 시간과 무관하지만, 액션이 개입하는 순간
  - 로직에 시간이라는 새로운 차원이 추가됨
  - 상태 업데이트와 부수효과를 비즈니스 로직과 섞는 것은 우리의 코드르 시간의 흐름에 종속시켜
  - 복잡성을 기하급수적으로 증가시키고, 테스트와 추론을 극돌고 어렵게만듬

## 결론적으로 React에게 비즈니릇 로직을 처리를 맡기는 것은 어불성설임

## 3. 비즈니스 로직 중심 설계 전략

앞서 식별된 문제들에 대한 전략적 해결책은 비즈이스 로직을 React프레인워크로 부터 완전히 분리하느것
이러한 디커프링을 통해 우린느 더욱 회복력이쏙, 테스트가 용이하며, 유비보수가 쉬원 애플리케이션의 구축할 수 잇음

### "React 코드 작성하기전에 React 없이 작성할 로직부터 고민하자."

프레임워크에 구애받지 않는 비즈ㄴ스 로직을 설계할떄 얻을 수 있느 주요 이점은 다음과 같음

1. 향상된 테스트 용이성
   1. UI와 결합된 로직은 실제 브라우저 환경을 모방하는 복잡한 E2E테스트를 필요로 하는 경우가 많음
   2. 반면 프레임워크와 독립적인 로직은 간단한 입력과 출려ㅛㄱ을 비교하는 단위 테스트로도 완벽하게 검증할 수 있음
2. 복잡성 감소:
   1. 계산을 액션으로부터 분리하믕로써
   2. 우리는 핵심로직엥서 예측 불가능한 시간이라는 차원ㅇ르 제거할 수 있ㅁ
   3. 순수하 ㄴ계산은 언제 몇번을 실행해도 항상 동일한 결과를 반환하느 ㄴ결정로적 특징을 가짐
3. 프레임워크 독립성
   1. 앱에서 가장 가치있느 자산은 UI가 아니라 비즈니스로직임
   2. 이 로직을 UI라이브러리부터 돌립식키면, UI기술 스태그이 변화와 무관하게 앱의 핵심 자산을 보존하고 이식할 수 있음
4. 개발자 생산성 향상
   1. 개발자는 프레임워크의 특정 기능이나 생명주기의 복잡성에 얽매이는 ㅅ대신, 해결할 비즈니스 문제 자체에 집중할 수 이음
   2. 이느 ㄴ더 명확한 사고를 가능하게 하고, 결국 더 효울적으로 가치를 전달하게 만듬

---

## 4. 비즈니스 로직을 주인공으로

확장 가능하고 유지보수가 용이한 REact앱을 구축하는길은 명확한 관심사의 분리에서 시작됨
