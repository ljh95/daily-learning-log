## 웹 데이터 로딩.

데이터 로직을 어디에 두어야 하는가?
UI 컴포넌트와 데이터 로직을 함께 배치하여 개발자 경험과 유지보수성을 극대화하려하고
또다른 의견은 네트워크 요청을 최소화하여 사용자에게 최고의 성능을 제공하려함

## 1. 최신 문법의 유혹: '서버 함수'가 숨기고있는 성능 회귀

데이터 로딩의 역사는 컴포넌트아ㅓㄴ에서 fetch를 호출하느 ㄴ패턴에서 시작됨
이 접근법은 데이터로직을 UI와 가깝게 두어 Colocation이라는 가치를 추족했지만,
그 대가로 심각한 성능 문제를 낳았음

각 컴포넌트가 개별적으로 데이털르 요청하면서 수많은 네트워크 왕복이 발생했고
이는 예측 불가능한 클라이언트-서버 워터폴 문제로 이어짐

이 문제를 해결하기 위해 서버 로더 패턴(Next.js의 getServerSideProps)가 등장ㅇ함
서버 로더는 페이지에 필요한 모든 데이터 로직을 서버의 단일 함수로 중앙화아혀
클라이언트에는 단 한번의 요청으로 모든 데이터가 전달되도록 보장함

Efficientcy 측면에서는 완벽한 해결책임
하지만 아키텍처 관점에서 이는 또다른 트레이드 오프를 낳음
데이터로직이 UI 컴포넌트 트리와 완전히 분리되면서 Colocatioj의 가치는 희생했음

바로 이 지점에서 서버함수가 배력적인 대안으로 떠올름
서버 함수는 클라이언트에서 서버로직을 호출할수 있게 해줌
이는 서버 로더가 포기했던 Colocation을 되찾으려함

하지만 함정이 있음
서버함수는 문법적 편의성을 제공했지만, 성능 특성은 과거의 '컴포너트 안에서 fetch'하는 시절로 회귀시킴
서버로더가 힘들게 해결했던 웣터폴을 다시 수면위로 끌어올림

데이터 로딩을 컴포너트와 함께 배치하느 ㅇㅇ도로 사용할 때, 서버함수느 ㄴ서버 로더보다 한 단계 후퇴한 것임
이 방ㅂ식은 데이터를 단일 라운드 틀립으로 가져오도록 상제하지 않으며, 클라이언트 서버 원터폴을 막지 못함

결국 문법의 간결함이 근볹거인 성능 문제를 해결해주지는 못했음
그렇다면 성능을 위해 슨히 사용되는 크랑인어트 캐싱을 해당되 될 수 있을까? 항상 그렇지만은 않음

## 2. 빠르다고 항상 좋은것은 아니다. 클라이언트 캐싱의 배신

'빠를수록 좋다'는 웹 성능의 금과 옥조로 여겨짐
하지만 클라이언트 측 캐싱이 항상 증정적인 사용자 경험으로 이어지는것은 아니라는 반직관적인 진실과 마주해야함
특히 state-while-revalidate 전략은 사용자 경험의 본질을 다시 생각하게 만듬

이전략은 화면에 오래된 데이털르 먼저 보여주고, 배경에서 조용히 새로운 데이터를 가져와 교체하는 방식
이론적으로 사용자에게 즉각적인 피드백을 주어 빠르게 느껴지게 함
그러나 사용자가 링크를 클릭하는 행위의 본질적인 의도는 최신 콘텐츠를 보는것
이런 상황에서 낡은 데이터가 잠깐 나타났다가 새로운 내용으로 바뀌는것은 사용자의 기대를 저버리는 행위이며, 혼란을 야기하는 더 나쁜 경험을 줄 수 있음

사용자는 자신의 행동이 최신 결과를 가져왔는지 확신할 수 없게 되고 무의식적으로 애플리케이션을 불신하게 됨

링크 클릭하는 행위에ㅅ는 신선함에 대한 기대가 담겨잇음
저는 혹시 모르닌 새로고침을 누르고 싶지 않습니다.

클라이언트 캐싱은 뒤로가기 버튼이나 탭 전화처럼 데이터가 변하지 않았을것이라 예상되는 상황에서는 강력한 도구임
하지만 새ㅗㄹ운 정보를 얻기 위해 탐색에서는 근본적인 해결채이 될 수 없음
클라이언트 단의 기교만으로는 한계가 명확함
지정한 아키텍처적 해답을 찾기 위해서는 문제의 근원으로 돌아가야함

## 3. 가장 혁신적인 길은 과거에 있었다. '단일 라운드트립'원칙으로의 회귀

데이터 로딩 방식의 역사를 돌아보면 흥미로운 패턴을 발견할 수 있음
전통적인 서버 렌덜인 HTML 앱에서는 단 한번의 요청으로 페이지에 피룡한 모든 데이터를 HTML에 담아 가져옴
이것이 바로 단일 라운드트립이라는 가장 효율적인 모델이었음
이후 클라잉너트 중심의 아키텍처로 넘어가면서 Colocation을 위해 이 원칙을 호ㅢ생ㅅ핶고 그 결과우리는 지금가지 논의산 성능 문제를 다시 마주침

놀랍게도 GraphQL Fragments, React Server Components같은 최첨단 기술들은 결국 '데이터를 한 번의 요청으로 가져온다'는 전통적인 HTML앱의 효율적인 모델로 회귀하고 있음
물론 과거와 똑같은 방식은 아님
이 기술들은 과거의 모델의 장점인 Efficiency와 현대적인 컴포넌트 아키텍처의 장점인 Coloctiopn을 모두 만족시키려는 정교하 시도임

- GraphQL Fragments
  - 각 컴포너트가 필요한 데이터 조각을 스스로 선언하게 함
  - 빌드 시점이나 런타임에 이 족각들이 자동으로 하나의 거대하 쿼리로 조합되어
  - 서버의 단 한번의 요청으로 모든 데이터를 가져옴
- React Server Components
  - 컴포너트 자체를 서버에서 실행되는 데이터 로더로 만듬
  - 서버에서 데이터로 로딩과 렌덜이이 모두 완료된 후
  - 그 결과물이 단일 페이로드로 클라잉넡으 스트리밍 됨
  - 이는 마치 컴포넌트 단위로 구성 가능한 서버 로더와 같음
    이런 접근법들은 Colocation과 Efficiency 사이의 줄달리기를 끝내고 모두 잡으려ㄴ는 지향저임

## 결론

웹 데이터 로딩 기술의 발전사는 효율성과 코드 배치라느 ㄴ두가지 중요한 가치 사이에서 최적의 귷ㄴ형점을 찾위위한 여정이었음
컴포넌트 안에서 fetch 를 하던 시절부터 서버로더 서버함수를 거쳐 마침내 과거의 지혜를 현대적으로 재해석하느 단계에 이름
