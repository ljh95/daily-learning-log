## 1. FSD의 규칙보다 ‘자연스러운 경계’를 먼저 찾으세요

제가 FSD를 제대로 이해하게 된 돌파구는 코드를 미리 정해진 틀에 끼워 맞추려 할 때가 아니었습니다. 오히려 개발자들이 본능적으로 코드를 작성하며 이미 만들고 있던 "자연스러운 경계"를 먼저 발견했을 때 찾아왔습니다.

이러한 자연스러운 경계란 우리가 이미 코드에서 분리하고 있던 책임의 단위들을 의미합니다. 예를 들어, 프론트엔드 개발의 핵심 흐름인 데이터 -> 화면(렌더링), 화면 -> 행동(사용자 인터랙션), 행동 -> 데이터(상태 변경 및 API 호출)라는 세 가지 명확한 경계가 존재합니다. 우리는 이미 UI 렌더링, 상태 관리 훅, API 통신, 순수 유틸리티 함수를 본능적으로 나누어 작성하고 있었습니다.

이미 알고 있던 경계들로 먼저 분리해두고 FSD에 억지로(?) 우겨넣다보니 더 체계적으로 정리할 수 있게 되었습니다.

따라서 FSD의 레이어 이름을 고민하기 전에, 먼저 여러분의 코드 작성 습관을 분석하여 이러한 자연스러운 분리 지점을 찾아보세요. 그 경계들을 명확히 하는 것만으로도 FSD 구조가 훨씬 명확해질 것입니다.

## 2. FSD는 폴더 구조의 ‘REST API’와 같습니다

FSD와 REST API 아키텍처를 비교하면 강력한 통찰을 얻을 수 있습니다. 과거 API는 /createUser, /updateUserPost처럼 기능마다 동사 기반의 엔드포인트를 만들어 일관성이 없고 예측하기 어려웠습니다.

이 문제를 해결한 REST는 GET, POST와 같은 고정된 HTTP 동사(verb)와 /users, /posts 같은 명사 기반의 리소스(noun)를 조합하는 표준을 제시했습니다. 이로써 API는 예측 가능한 구조를 갖게 되었습니다.

FSD도 정확히 같은 방식으로 작동합니다. Layers(entities, features)와 Segments(ui, model, api)는 고정된 "동사"와 같고, Slice(user, product)는 "명사", 즉 리소스입니다. 이 조합은 features/cart/ui처럼 팀의 누구나 직관적으로 이해할 수 있는 예측 가능한 구조를 만들어냅니다.

마치 REST API가 HTTP 메서드와 리소스의 조합으로 명확한 구조를 만들어냈듯이, FSD도 마치 가운데 slice(=resource)를 기준으로 앞뒤의 정해진 이름을 붙이고 이를 조립해서 어떤 파일이 있을지 예측 가능한 구조를 만들어내고 있었습니다.

## 3. 규칙이 아닌 ‘팀 컨벤션’을 만드는 도구로 활용하세요

FSD를 따라야 할 엄격한 교리가 아닌, 팀의 합의와 공통 언어를 만드는 도구로 바라보아야 합니다. 저희 팀에서는 "FSD 상상 놀이"를 해보는 것이 큰 도움이 되었습니다. 예를 들어, features/cart/model이나 entities/product/ui 같은 특정 경로에 어떤 종류의 코드가 들어갈지 함께 상상해 보는 것입니다.

이 연습은 "정답"을 찾는 것이 목적이 아닙니다. 팀원들의 머릿속에 있는 멘탈 모델을 일치시키고, 우리 팀만의 실용적이고 합의된 컨벤션을 만드는 과정 그 자체가 중요합니다.

정해진 정답이 있는게 아니라면 우리 팀의 모두가 함께 상상 가능한 것이 예측가능하고 일관성이 있는 답이 될테니까요.

FSD의 진정한 힘은 "이 코드는 어디에 두어야 할까?"에 대한 논쟁과 커뮤니케이션 비용을 줄여주는 데 있습니다.

3.5. 감각으로 경계 정의하기: Entities는 데이터, Features는 액션

규칙보다 팀의 '감각'을 맞추는 것이 더 중요합니다. 저희는 다음과 같이 각 레이어에 대한 느낌적인 느낌을 공유하며 경계를 정의했습니다. 이는 FSD의 가장 모호한 부분을 명쾌하게 만드는 데 결정적인 역할을 했습니다.

- Entities: data, read, pure, query, render 같은 느낌. 수정되지 않는 원본 그 자체이며, 주로 데이터를 표현하고 읽는 역할에 집중합니다.
- Features: action, write, mutation, state, store 같은 느낌. 사용자의 행동으로 인해 발생하는 상태 변경이나 비즈니스 로직을 처리합니다.
- Widgets: 이렇게 딱 떼어내도 위화감이 없는 독립적인 UI 블록. 여러 엔티티와 피처를 조합하고 레이아웃을 구성하는 역할에 집중합니다.

이런 감각적인 정의는 완벽한 규칙은 아닐지라도, 팀원들이 같은 그림을 그리게 만들어 논쟁의 90%를 줄여주었습니다.

## 4. 처음부터 모든 것을 나누려 하지 마세요 (점진적으로 확장하기)

많은 개발자가 저지르는 흔한 실수는 작은 프로젝트 초기부터 FSD의 모든 폴더 구조를 복잡하게 만들어두는 것입니다. 이러한 과도한 엔지니어링은 FSD에 대한 좌절감의 주된 원인입니다. 대신 실용적이고 점진적인 접근 방식을 따르세요.

- 단순하게 시작하세요: 처음에는 pages(ui, model, api로 분리)와 shared(ui, lib) 같은 최소한의 구조로 충분합니다.
- 데이터와 렌더링 패턴이 보이면 entities로 분리하세요: 코드베이스가 성장하며 특정 도메인의 데이터와 이를 렌더링하는 코드가 반복된다면 entities로 옮겨 관리합니다.
- 사용자 액션으로 복잡해지면 features로 리팩토링하세요: 하나의 컴포넌트에 이벤트 핸들러가 2~3개 이상 쌓여 책임이 복잡해지기 시작하면, 그 부분을 features 슬라이스로 추출합니다.
- 여러 조각이 모이면 widgets으로 조합하세요: 여러 피처나 엔티티가 결합되어 하나의 독립적인 블록을 형성한다면, 이를 widgets 슬라이스로 추출하여 조립과 레이아웃만 담당하게 합니다.

핵심은 코드를 미리 정의된 구조에 억지로 맞추는 것이 아니라, 코드가 성장함에 따라 적절히 가지치기 해가듯 확장하는 게 주요했습니다.

또한, 모든 프로젝트에 FSD를 똑같이 적용할 필요는 없습니다. 프로젝트의 성격에 따라 구조는 달라져야 합니다. 예를 들어, Admin Console은 엔티티 중심의 CRUD가 핵심이므로 entities가 풍부해지고, 복잡한 애플리케이션은 다양한 features와 widgets이 필요합니다. 반면, 페이지별 독립성이 강한 홈페이지 같은 프로젝트는 일반적인 FSD 구조를 따를 경우 오히려 코드가 파편화될 수 있습니다. 이럴 땐 pages 폴더 안에서 다시 FSD 패턴을 중첩하여 사용하는 것이 훨씬 효과적이었습니다.

## 5. FSD는 경계를 ‘정해주는’ 것이 아니라 ‘보이게’ 해줍니다

마지막으로 가장 철학적인 인사이트는 무지개 색깔의 비유에서 나옵니다. 무지개는 원래 연속적인 스펙트럼이지만, 우리가 '빨주노초파남보'라는 7가지 색의 이름을 배우면서 비로소 그 경계를 뚜렷하게 인식하게 됩니다. 이름이 있기 전에는 경계가 명확하지 않았습니다.

FSD는 우리 코드베이스에 똑같은 역할을 합니다. app, entities, features, ui, model 같은 레이어와 세그먼트의 이름은 이전에는 모호했던 코드의 경계를 보고, 토론하고, 명확하게 만들 수 있는 어휘를 제공합니다.

무지개는 원래 7색이 아니었다고 합니다. ... 명명이 되어 있고 인식이 있기에 경계를 구분할 수 있게 되는 것이죠. FSD의 의의는 마찬가리라 생각합니다.

FSD를 완벽하게 구현하지 못하더라도, FSD를 배우는 것의 궁극적인 가치는 개발자가 코드를 더 구조적인 관점으로 보고 정리하도록 훈련시킨다는 데 있습니다.

## 결론: 경계보다 중요한 것

이 글의 핵심 메시지를 요약하자면, FSD는 엄격한 법이 아니라 유연한 컨벤션이자 커뮤니케이션 도구입니다. 모든 코드를 완벽하게 분류하는 것보다, 팀의 생각을 일치시키고 예측 가능한 구조를 만드는 데 FSD의 진정한 힘이 있습니다.

어떤 경계를 선택했는지보다, 그 경계를 팀 전체가 일관되게 적용하는 것이 훨씬 더 중요합니다.
