## 이터레이터 헬퍼: 더 효율적인 데이터 처리를 위한 제안

대용량 데이터 처리하면서 filter, map slice가 연달아 사용하다가 브라우저가 멈추거나 불필요한 중가 베열이 계속 생성되어 메모리가 낭비되는 경험을 해본적없나요?
for 루프 속에서 비즈니스로직을 파악하기 어려워 코드 가독성이 떨어졌던기억은 없나요?

이터레이터 헬퍼는 바로 이 문제들을 해결하기 위해 등장한 강력한 도구임
우리 코드으이 가독성, 메모리 효율성, 그리고 성능을 횩신적으로 개선할 수 있는지 구체적인 예시와 데이터로 보여줄 것

## 1. 기존 이터레이터 활용의 한계

ES2015에 이터레이터 프로토콜리 처음 도입되었을때, 우리는 데이터 시퀀스를 ㅏ루는 새로운 표준을 얻었음
하지만 개발 현장에서 이터레이터를 적극적으로 활용하기엔 몇가지 한계가 존재함

- 직접 구현의 어려움:
  - filter난 maprrㅘ 같은 기본적인 기능조차 이터레이터 프로토콜을 준수하며 직접 제너레이터 함수 등으로 구현해야 했음, 이 과정은번거롭고 오류 발생 가능성ㅇ도 높고 우리가 필요한 다양한 기느을 모두 구혀나기에 한계가 있음
- 배열 변환의 비효율성:
  - 가장 손쉬운 대안은 이터레이터를 Array.from()이나 스프레드 문법을 사용해 배열로 변환한뒤익숙한 배열 메서드를 사용하는 것임, 하지만 이 방식은 이터레이터의 가장 큰 장점인 지연 평가를 포기하는것임
  - 모든 데이터를 메모리에 올리는 순간, 대용량 데이터 처리시 불필요한 메모리 낭비화 성능저하가 발생하게 됨

## 2. 지연 평가의 동작 방식 이해하기

지연 평가는 이너레이터 헬퍼의 강력한 성능과 효율성을 이해하는 가장 중요한 개념임
이는 필요할때까지 계산을 미루는 방식으로 모든 것을 미ㅣ 계산해 메모리에 올려두는 배열의 즉시 평가 방식과 근본적인 차이가 있음'

### 2.1 기본동작 비교: 배열 vs 이터레이터

1부터 5까지 합을 구하는 간단한 예제를 통해 두방시의 차이를 살표보겠음

// 1. 배열
const arr = Array.from({ length: 5 }, (\_, i) => i + 1);
const arrSum = arr.reduce((a, c) => a + c, 0);
console.log(arrSum); // 15

// 2. 이터레이터 (지연 평가)
function\* generator() {
let i = 0;
while (i < 5) yield ++i;
}
let iterSum = 0;
for (const v of generator()) {
iterSum += v;
}
console.log(iterSum); // 15

두 코드 결과는 15로 동일하지만, 내부 동작 방식은 완전히 다릅니다.
각 코드에 로그를 추가해 실행 흐름을 추적해보겠음.

// 배열 실행 흐름
console.group('array');
const arr = Array.from({ length: 5 }, (\_, i) => {
console.log('generate', i);
return i + 1;
});
arr.reduce((a, c) => {
console.log('reduce', c);
return a + c;
}, 0);
console.groupEnd('array');

// 이터레이터 실행 흐름
console.group('iterator');
function\* generator() {
let i = 0;
while (i < 5) {
console.log('generate', i);
yield ++i;
}
}
for (const v of generator()) {
console.log('reduce', v);
// iterSum += v;
}
console.groupEnd('iterator');

콘솔 출력 결과를 비교하면 그 차이가 명확히 드러납니다.
배열 (즉시 평가)
이터레이터 (지연 평가)
generate가 5번 모두 실행된 후<br>reduce가 5번 실행됨
generate와 reduce가<br>번갈아 가며 한 번씩 실행됨

배열은 Array.from 이 실해되는 시점에 모든 요소를 메모리에 생성한 뒤 reduce가 이 배열을 순회하며 연산을 tlwkrgka
반면 이터레이터는 for...of 루프가 next()를 호출하ㅡㄴ 시점에 단 하나의 요소를 평가하고 즉시 연산을 수행한뒤 다음 요소를 위해 다시 대기함

### 2.2 메서드 페이닝에서느니 동작 비교

const arr = [1, 2, 3, 4, 5];
const arrResult = arr
.filter(v => {
console.log('filter', v);
return v % 2 === 0;
})
.map(v => {
console.log('map', v);
return v \*\* 2;
});
// 로그 실행 순서:
// filter 1
// filter 2
// filter 3
// filter 4
// filter 5
// map 2
// map 4

로그를 봅면, filterrㅏ 먼저 전체 배열열 5개를 순회하고, 그 결과로 생성된 새ㅗ로운 배열 2, 4를 map이 다시 순회함, 총 2번의 전체 순회가 발생함

이제 이터레이터가 어떻게 동작하는지 살펴보겠음
다음은 이터레이터 헬퍼의 동작 원리를 이해하기위해 Iterator.prototype에 직접 메서드를 추가한 예시임

Iterator.prototype.\_filter = function\* (fn) {
for (const item of this) {
if (fn(item)) yield item;
}
}

Iterator.prototype.\_map = function\* (fn) {
for (const item of this) {
yield fn(item);
}
}

const arr = [1, 2, 3, 4, 5];
const iter = arr
.values()
.\_filter(v => v % 2 === 0)
.\_map(v => v \*\* 2);

console.log(iter); // Iterator.\_map {<suspended>}

\_filter와 \_map 을 호출한 직후 ㅑter를 출력해보면, 실제 연산이 일어난 것이 아니라 suspended(중단됨)상태의 이터레이터가 반환된 것을 벌 수 있음

실제 평가는 for of나 스프레드 문법처럼 이터레이터를 소비하는 시점에 시작됨

iter.next()r가 호출될 댸 내부 실행 흐름은 다음과 같이 동작함

1. 가장 바깥쪽의ㅡ \_map 이터레이터에게 next() 요청을 함. \_map실행은 running 상태임
2. \_map은 값을 yield 하기 위해 자신의 for-of 루프를 실행함. 이루프는 this(\_filter)에게 값을 요청함
3. \_filter 이터레이서 실행됨, 이 이터레이터 역시 값을 yield하기 위해 자신의 for-of fㅜ프를 실행하고, this(원본 배열의 values 이터레이터)에게 값을 요청함
4. 원본 values 이터레이선 실행되어 첫 번째 ㄱ밧 {value:1, done:false}를 yield 함
5. \_filter가 값을 1 받아 조건을 검사함, 1%2===0은 false이므로 아무것도 yield하지않고 다음 루프를 돔, ㄷ다시 values dㅔ게 값을요청함
6. values 이터레이터가 두 번째 값 {value:2, doen:false}ㄹㄹ yield함
7. \_filterrㅏ 2를 받아 조건은 검사함, ture이므로 2를 yield하고 \_filter는 잠시 멈춤
8. \_map이 드디어 \_filterfㅗ부터 2를 받음, \_map은 이 값을 \*\*2 연산을 적용해 4를 만들고 {value:4, doen:false}를 최종적으로 yield함, 전체 실행이 멈추고 다시 suspended상태로 도ㄹ아감
   이 복잡한 ㄷ과정의 핵심음 각 요소에 대해 연결된 모든 메서드ㅡㄹ 순차적으로 실행한뒤 다음 요소롤 넘어간다는 점
   ㅇ이롱 ㅣㄴ해 전체 데이터에 대한 순회 횟수가다 단 한번으로 줄어듬
   지연 평가의 원리를 통해 순회 횟수를 획기적으로 줄이는 방법을 확인함, 이제 이 강력한 원리를 표준으로 탭재한 ES2025 이터레이터 헬퍼 기능을 본격적으로 살펴보겠음

## 3. 새로운 도구: ES2025 이터레이터 헬퍼

이제 지연평가 기반의 메서드 체이닝 원리르 개발자가 직접 구현할 필요없이 표준화되고 사용하기 ㅜ식베 만든 것이이터레이터 헬퍼임,

### 3.1 이터레이터를 소비하지 않는 메서드 (새로운 이터레이터 반환)

이 메서드들은 호출 자체만으로는 평가각 이루어지지 않음,
대신 새로운 이터레이터를 반환하여 계속해서 메서드 체이닝을 이어갈 수 ㅇㅆ게 해줌

- map:
  - 각 용소에 함수를 적용한 결과로 새 이터레이터를 반환함
- filter:
  - 조건 함수를 통과하는 요소만으로 구선된 새 이터레이터를 반환함
- .take
  - 처음부터 limit개수만큼의 요소만 포함하는 새 이터레이터를 반화함 slice와 유사
- drop
  - 처음부터 limit 개수만크의 요소를 제외한 나머지로 구성된 새 이터레이터 반환함
- flatMap
  - 각 용소에 매핑함수를 적용한 수 굘과를 1 단계 깊이로 편탄화한 새 이터레이터를 반환함

### 3.2 이터레이터를 소비하는 메서드 (최종 값 반환)

이 메서드들은 메서드 체인의 마지막에서 실제 ㅔ평가를 시작하고, 이터레이터가 아닌 최종 결과값을 반환함.따라서 이 메서드 호출 이후에 더이상 이터레이터 메서드를 체이닝할 숭 ㅓㅂㅅ음

- reducer
  - 각 요소를 순회하며 누적 연산을 수행해 단일 값을 반환함
- toArray\*
- 이터레이터의 모든 요소를 담은 새로운 배열 반환
- forEach
  - 각 요소를 대해 콜백 실행
- some
  - 조건을 맍고하는 요소있다면 tru 반환
- every
  - 모든 조건 만족하면 trye
- find
  - 조건 맍고하는 첫번쨰 요소반환

### 3.3 정적 메서드

- Iterator.from:
  - 이메서드의 핵심 역할은 어떤 이터러블 객체나 이터레이터 ㅍ로토콜을 따르는 객체든,헬퍼 메서드를 사용할 수 있는 표준 Iterator 인스턴스로 변환해주는 유틸리티 임
  - Iterator.from은 인자의 종류에 따라 다음과 같이 동작함

1. 인자가 이미 Iteracto 인스턴스인 경우: 제너레이터 포함 인자를 그대로 반환함
2. 인자가 이터레이터 프로토콜을 ㅂ따르는 일반 객체의 경우: next() 메서드른 있지만 헬퍼 메서드는 없는 객체를 표준Iteraotor 인스턴스로 감싸서 반환함
3. 인자가 이터러블 객체인 경우 (Array, String, Map)객체의 [Symbol.iteratyor]메서들 호출하여얻은 이터레이터에 위 1번 또는 2번 규칙을 적용함

5천만 개의 데이터 중 특정 조건(isVisible)을 만족하는 10개의 페이징 데이터를 가져오는, 보다 현실적인 시나리오입니다.
// 배열 방식 테스트 함수
const getPageDataArray = (offset = -1) => target =>
target
.slice(offset + 1)
.filter(v => v.isVisible)
.slice(0, 10) // pageSize
.map(v => v.index);

// 이터레이터 헬퍼 방식 테스트 함수
const getPageDataIterator = (offset = -1) => target =>
target
.drop(offset + 1)
.filter(v => v.isVisible)
.take(10) // pageSize
.map(v => v.index)
.toArray();
결과는 압도적입니다.
환경
배열
이터레이터 헬퍼
Chrome
665.720 ms
0.010 ms
Firefox
826.900 ms
0.100 ms
Safari
1160.100 ms
0.800 ms
Node.js
0.010 ms
0.004 ms

"So What?" 이 결과가 의미하는 바는 명확합니다. 배열 방식은 filter 단계에서 불필요하게 5천만 개의 모든 데이터를 순회하지만, 이터레이터는 지연 평가 덕분에 take(10)에 필요한 10개의 데이터를 찾는 순간 순회를 멈춥니다. 이로 인해 성능과 메모리 사용량에서 비교할 수 없는 이점을 가집니다.
결론: 단일 순회의 미미한 성능 차이보다, 복잡한 연산에서 순회 횟수를 줄여 얻는 성능 및 안정성(메모리 초과 방지) 이점이 훨씬 큽니다. 또한 V8 등 자바스크립트 엔진이 지속적으로 최적화되고 있음을 고려할 때, 이터레이터의 기본 성능 역시 계속해서 개선될 것입니다.
