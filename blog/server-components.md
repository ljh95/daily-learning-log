CSR 와 SSR 사이에 고통스러운 트레이드 오프가 있었다.
CSR은 뛰어나 ㄴ개발자 경험을 제공했지만 사용자는 쵝 로딩 시 빈화면을 마주해야하는 UX 저하를 마주해야했음
반면 SSR은 초기 로딩 속도는 개선햇지만 서버 부하 증과와 전체 로딩 시간 지연이라는 다른 문제를 낳음

이런한 오랜 고미 끝에 사세대 혁신이 바로 React 서버 콤포넌트이다.

## 1. 렌더링 전략, 이제 컴포넌트 단위로 결정하세요

React 서버 컴포넌트가 가져온 가장 큰 페러다임 변화는 렌더링 전략을 더이상 페이지 전체에 적용하지 않는다는점
이제 개발자는 개별 컴포너트 수준에서 최적의 렌더린 방식을 선택할 수 있다.

왜 중요할까?
이 유연성 덕분에 개발자는 ㅍ로젝트의 각 부분에 가장 적합한 렌더링 방식을 조합하여 사용할 수 ㅣㅇ씅ㅁ
가련 전자상거래 페이지를 만든다면
제품의 상세 설명과 사양처럼 데이터베이스에 가깝고 정적인 정보는 서버 컴포넌트로
반면 ㅈ장바구니 담기 버튼이나 인터랙티브한 이미지 갤러리처럼 상태와 이벤트 핸들러가 필요한 부분은 클라이언 컴포넌트로 작성한다.
이를 통해 개발자는 성능과 사용자 경험 사이에 최적의 규현점을 찾으 수 있다.

## 2. 브라우저 다이어트: 서버 컴포너트틑 자바스크립트를 보내지 않음

서버 컴포너트는 이름 그대로 서버에서만 실행되며, 그 코드는 절대 브라우저로 전송되지 않음
브라우저가 받는 것음 렌더링 결과물인 HTML 뿐

이는 CSR의 가장 큰 약점인 거대한 초기 번들 사이즈 분제를 정면으로 해결함
예를 들어 날짜 포멧팅이나 마크다운 파싱을 위해 대용량 라이브러리를 사요하는 컴포너트가 있다면
이 컴포넌트를 서버 컴포너트 만들면 해당 라이브러리는 서버에만 머물게 되어, 번들 크기가 크게 줄어들게 되어 초기 페이지 로드 성능이 극적으로 샹항하게 됨

또한 서버 컵포넌트는 클라이언트에서 자바스크립트 코드를 실행하여 HTML 에 생명을 불어넎는 하이드레이션 괒엉이 전혀 피료 없음
이는 상호작용까지 결정적 경로에서 비용이 많이 드는 단계를 제거하는것과 같다.

## 3. '클라이언트 컴포넌트'의 오해: 사실 서버에서도 먼저 렌더링됩니다.

파일 상단에 "use client" 지시어를 붙여 정의하는 클라이언트 컴포넌트는 이름 때문에 클라이언트에서만 실행될것이라 생각하기 쉬운데
이는 사실과 다름

Next.js 와 같은 프레임워크 초기 HTML 을 생성하기 위해 서버에서 클라이언트 컴포넌트를 미리 렌더링 합니다.
덕분세 사용자는 자바스크립트가 로드되는 동나 빈 화면을 보는 대신 즉시 콘텐츠가 채워진 페이지를 볼 수 있다.
이후 브라우저로코드가 전송되면 하이드레이션 과정이 진행되며 컴포넌트가 상호작용 가능하게 됨
이는 SSR의 장점인 빠른 초기 콘텐츠 표시를 그래로 계승하는 영리한 메커니즘임

## 4. 기다림의 종말: 스트르밍으로 완성되는 점진적 UI

기존 SSR의 가장 큰 단점중 하나는 '전부 아니면 전무'방식이였습니다.
서버가 페이지 전체의 데이터를 페칭과 렌더링을 마칠때까지 브라우저는 아무것도 보여주지 못하고 기다려야만 했음

RSC는 <Suspense> 와 결합하여 이 문제를 스트리밍으로 해결함
서버는 준비된 컴포넌트로부터 즉시 HTML로 변환하여 브라우저로 전송하고, 데이터 로딩처럼 시간이 걸리는 컴포넌트 자리에는 로딩 스피너와 같은 폴백이 나갑니다.
이후 데이터 로딩이 완료되면, 해당 컴포넌트의 완성된 HTML 과 RSC Payload라는 특별한 데이터가 새로운 청크로 스트리밍되어 기존의 폴백 UI를 대체함

이 RSC Payload 는 렌더링된 HTML 클ㄹ라이너트 컴포넌트가 들어갈 자리 표시자, 그리고 해당 컴포넌트의 자바스크립트 파일 참조 등을 포함하는 특별하고 압축된 데이터 형시임
ㅈ본질적으로 브라우저가최종 인터랙티브 페이지를 조립하는데 사용하는 설명서와 같음

이것은 단순한 이롱이 아님
네트워크 트래픽을 살펴보며 서버가 Transfer-Encoding: chunked 헤더를 보내는것을 볼 수 있음
이것은 브라우저에게 전체 응답이 끝나기 전이라도 첫 번째 HTML 조각을 받는 즉시 UI를 그리기 시작하라고 알리는 저수준 신호임
바로 이 기술적이 ㄴ마법이 끊김 없이 사용자 경ㅁ허음 가능하게 함

## 5. 이상한 규칙: 서버 컴포넌트를 클라이언트 컴포넌트롤 import 할 수 없는 이유

RSC 를 사용하다 보면 마주치는 가장 중요하고 미묘한 규칙이 하낭 ㅣㅆ음
바로 클라이언트 컴포넌트 파일에서 서버 컴포넌트를 직접 ㅑmport 할 수 없다는 제한임

그 이유는 두 컴포너트가 실행환경에서 생명주기가 근본적으로 다르기 떄문
클라이언트 커뫂넌트는 상태 변경에 따라 브라우저에서 수시로 리렌더링 도리 ㅅ 있지만
서버 컴포넌트는 그럴 수 없음
이를 박기 위해 직접적인 import가 제한된 것

하지만 반전이 있음
사실 서버 컴포넌트를 클라이너트 컴포넌트에서 import 하는 것이 기술적으로 불가능하지 않음
다만, 이때 서버 컴포넌트는 클라이언크 컴포넌트로 변환 되어 버림
만약 해당 서버 컴포넌트가 서버 전용 API를 사용하지 않았다면,
그 코드는 브라우저로 유출되어 클라이언트 번들에 포함되고 맘
이는 서버 컴포넌트를 사용하는 모적 자체를 무의미하게 만듬
이 뉘앙스를 기억해야함

그렇다면 해결책은?
서버 컴포넌트를 클라이언트 컴포넌트의 children prop으로 전달하는 것
이것은 두 컴포넌트유형의 경계를 존중하면서 자연스럽게 조합하는 가장 일반적이고 권장되는 패턴임

지금까지 살펴본 5가지 사실은 RSC가 어떻게 CSR의 인터랙티브한 경험과 SSR 의 빠른 초기 로징이라는 잔점을 결합하여 웨 개발의 새로운 가능성을 열었는지 보여줌
서버 컴포넌트는 번들 크기를 줄이고 클라이언트 컨포넌트는 서버에서 미리 렌더링되며, 스트리밍은 점진적인 UI 로딩이 가능하게 함

이는 이론적인 개선이 아니면 실제 성능 분석에 따르면,RSC 의 스트리밍 아키텍처는 브라우저가 전체 데이터 요청이 완료되기 전부터 리소스 로딩과 ㅔ이지 구성을 시작하게 해줌
인ㄴ 전통적인 방시에 비해 측정가능핮 ㅓㅇ도로 향상된 코어 웹 바이탈 수치와 근본적으로 더 빠른 사용자 경험ㅇㅁ

물론 RSC가 상태 관리나 인증과 같은 새로운 과제를 제시하기도 하지만, 그 이점은 매우 강력함
RSC는 렌더링 파이프라인에 대한 외과적인 수준의 제어권을부여함
이제 질문은 더 빠른 경험을 만들 수 있는가가 아니라, 이 강력한 힘을 당신의 다름 프로젝트에서 어떻게 활용할것인가 이다.
