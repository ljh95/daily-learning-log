## 1. 당신의 핵심 로직은 프레임워크와 무관하다.(The Domain Layer)

클린 아키텍처의 심장부에는 '도메인 레이어'가 있음
도메인은 애플리케이션의 본질적인 비즈니스 로직와 엔티티를 담고 있는 여역으로 다른 앱과 구별됨

가장 중욯나점은 이 도메인 로직인 React나 Angular 같ㅇ느 UI프레인워크로 부터 완전히 독립적이라는 사실임
프레임워크가 바뀌더라도 도메인은 변하지 ㅇ낳아야 함
예를 들어,
장바구니에 상품ㅇ르 추가하는 함수는 사용자가 직접 구매 버튼을 눌러서 상품을 추가했는지, 아니면 프로모션 코드로 자도 ㅇ추가되엉ㅆ는지 신경쓰지 ㅇ낳음
두 경우 모두ㅠ 동일하게 상품을 받아 업데이트된 장바구니를 반화할 뿐

이러한 분리 덕에 우리는 외부 환경에 대하 ㄴ거정없이 핵심 기능을 독립적이고 테스트핳고 논리적으로 추론할 수 있음

도메인 엔티티의 데이터 구조와 그 변환의 본질은 외부 세계와 무관하다.
외부 이벤트는 도에민 변환을 촉발할 수는 있지만, 그것이 어떻게 일어날지 결정하지는 않는다.

## 2. 세상을 앱에 맞추는 것, 그 반대가 아니다(The Dependency Rule)

클린 아키텍처에서 가장 중요하가 강력하 ㄴ규칙은 바로 의존성 규칙임
오직 바깥쪽 래이어만이 안쪽 레이어에 의존할 수 있다는 단 하나의 원칙임

간단히 말해, 비즈니스로직은 애플리케이션 로직에 대해 아무것도 알라서는 안되며,
애플리케이션 로직은 UI나 외부 서비스 에 대해 아무것도 알아서는 안됨

이는 직관에 반하는 것처럼 보이지만 매우 강력한 아이디어를 ㅏㄷㅁ고 있음
바로 우리가 외부 세계를 우리의 필요에 맞게 조정하는 것이지
그 반대가 되어서는 안된다 라는 것

이것은 애플리케이션이 정의한 포트와 외부 서비스가 이 인터페이스를 따르도록 구현한 어댑터를 통해 실현됩니다.

예를 들어, React 컴포넌트는 사용자의 클릭이벤트를 앱이 이해할 수 잇느 ㄴ신호로 변환하는 주도 업댑터이며
서버 API를 호출하는 모듈은 앱의 요청을 외부 세계로 전달하는 피주도 어댑터입니다.
이 접근법 덕분에 우리는 필요에 따라 외부 결제 시스템이나 API 서버 같은 서드파티 서비스를 손쉽게 교체할 수 있습니다.

## 3. "불순한 샌드위치"로 부수 효과를 제어하라.(Function Core, Imperative Shell)

그렇다면 유스케이스를 어떻게 구현해야할까?
클리아키텍처는 "순수한 변환을 위한 불순하 컨텍스트" 또는 "명령형 껍질 속의 함수형 코어"라는 실용적인 패턴을 제시함

이 샌드위치 패턴(마치 샌드위치처럼 순수한 핵심 로직은 양쪽의 불순한 부수 효과가 감싸는 구조)은 다음고 ㅏ같은 단계로 이루어짐

- 1단계(부수 효과): 외부 세계에서 데이터를 가져옴(예, API 호출, 로컬 스토리지 읽기)
- 2단계 (순수 함수): 부수 효과가 없는 순수하 도메인 함수르 ㄹ사용해 핵시 ㅁ로직을 처림함
- 3단계 (부수 효과): 처리된 결과를 다시 외부 세계에 저장하거나 전달함

이 패턴이 강력한 이유는 예측 불가능한 외부 시스템과의 '불순한' 상호작용으로부터 복잡하고 '순수한' 핵심 로직을 완벽히 분리하기 때문입니다. 이는 곧 여러분의 핵심 비즈니스 로직이 API, 브라우저 환경, 혹은 상태 관리 라이브러리를 모킹(mocking)할 필요 없는 단순한 단위 테스트로 검증될 수 있다는 의미입니다. 이를 통해 테스트 스위트는 극적으로 단순해지고 코드에 대한 신뢰도는 높아집니다.

## 4. 클린 아키텍처는 공짜가 아니고 타협할 수 있다.

클린 아키텍처는 강력하지만, 비용이 있다느,ㅈ ㅁ은 인정해야함
시간, 콯드랴ㅕㅇ 증가, 온보딩의 어려움
하지만 비용울 중ㄹ히 ㄴ방법있음

1. 도메인 분리하기

   1. 핵심 비즈니스 로직을 코드베이스의 다른 부분과 명확하게 분리하세요.
   2. 분리된 도메인은 새로운 개발자가 애플리케이션의 엔티티와 그 관계를 더 쉽게 파악하도록 돕습니다
   3. 코드베이스 전체에 흩어져 있는 것보다 분리된 도메인을 다루고 리팩토링하는 것이 훨씬 수월하기 때문입니다.

2. 의존성 규칙 준수하기
   1. 외부 서비스가 여러분의 애플리케이션 필요에 맞춰지도록 하세요
   2. 만약 특정 검색 API를 호출하기 위해 여러분의 코드를 '미세 조정'하고 있다는 느낌이 든다면, 무언가 잘못된 것입니다. 문제가 더 퍼지기 전에 어댑터를 작성하는 편이 낫습니다.

## 5. OOP는 필수가 아니다 (OOP is Orthogonal)

- 아키텍처의 본질은 엔티티의 구성과 관심사의 분리에 있으며,
- , '구성의 단위'가 객체여야 하는지 함수여야 하는지를 강제하지 않습니다.
- 소스에서 제공된 쿠키 스토어 예제 역시 OOP에 크게 의존하지 않고 설계되어, 아키텍처의 유연성을 보여줍니다.
- 우리는 OOP에 대해 거의 다루지 않았다. 왜냐하면 아키텍처와 OOP는 직교(orthogonal) 관계이기 때문이다.
- 다. 아키텍처는 엔티티의 구성에 대해 이야기하지만, 구성의 단위가 객체여야 하는지 함수여야 하는지는 규정하지 않는다

## Conclusion: 작은 시작이 변화를 만든다

- 클린 아키텍처는 보일러플레이트를 추가하는 것이 아니라, 코드에 대한 통제권을 되찾는 철학입니다.
- 당신의 애플리케이션이 '무엇인지'(도메인)와 '어떻게 세상과 상호작용하는지'(어댑터)를 의식적으로 분리함으로써, 여러분은 핵심 로직 주위에 견고한 요새를 구축하게 됩니다.
- 작게 시작하되, 생각은 크게 하십시오.
- 다음에 함수를 작성할 때 스스로에게 물어보세요. "이것은 핵심 비즈니스 규칙인가, 아니면 프레임워크의 세부 사항인가?"
