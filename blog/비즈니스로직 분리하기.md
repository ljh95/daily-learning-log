기계적인 코드 분리를 넘어, 코드의 역할과 책임을 어떻게 격리하고 추상화할 것인지에 대한 깊은 고민이 필요하다.
이 글에서 엉킨 코드를 명확하고 견고하게 만드는 3가지 강력한 생각의 전환법 소개

## 1. '추출'을 넘어 '추상화'로: 레고는 어떻게 실을 이기는가?
우리는 흔히 거대한 함수를 여러 개의 작은 함수로 나누는 작업을 '분리'라고 생각함
하지만 이는 절반만 맞는 말
진정한 분리를 이해하기 위해서는 먼저 '추출'과 '추상화'의 차이에 대해 알아야함

- 추출: 
  - 코드의 일부를 물리적으로 다른 곳으로 옮기는 행위 자체
  - 긴 함수를 짧게 만들거나 중복 코드를 별도로 분리하는것
  - 코드의 가독성 일부를 개선할 수 있지만, 근본적인 구조를 바꾸지는 못함
- 추상화:
  - 한단계 더 나아간 개념
  - 코드 조각이 '무엇을 하는지'
  - 그리고 '왜 필요한지'에 대한 본질을 파악하고
  - 그 개념을 하나의 단위로 정의하는 과정
  - 코드의 의도를 파악하여 더 일반화된 형태로 개념화하는 지적인 활동

### 예시
아래 두 함수는 각각 아이템의 quantity와 size를 1씩 증가시킴
```js
// 수량(quantity) 필드명이 함수에 하드코딩 되어 있음
function incrementQuantity(item) {
  const quantity = item.quantity;
  const newQuantity = quantity + 1;
  const newItem = objectSet(item, 'quantity', newQuantity)
  return newItem;
}

// 크기(size) 필드명이 함수에 하드코딩 되어 있음
function incrementSize(item) {
  const size = item.size;
  const newSize = size + 1;
  const newItem = objectSet(item, 'size', newSize);
  return newItem;
}
```

두 함수는 필드 이름만 다를 뿐 로직이 완전히 중복됨
이는 단순한 추출의 한계

이제 추상화를 통해 특정 필드의 값을 1 증가시킨다는 개념을 도출해보자.
필드 이름을 인자로 받으면 됨
```js
function incrementField(item, field) {
  const value = item[field];
  const newValue = value + 1;
  const newItem = objectSet(item, field, newValue)
  return newItem;
}
```

한 단꼐 더 나아감.
하지만 여기서 는 동작 자체도 더 일반화 가능
"값을 1 증가시킨다" -> "객체의 특정 필드 값을 업데이트한다"로 추상화 가능

```js
// 객체, 키, 변경 함수를 인자로 받는 범용 update 함수
function update(object, key, modify) {
  const value = object[key]
  const newValue = modify(value)
  const newObject = objectSet(object, key, newValue)
  return newObject
}

// update 를 활용해 incrementField를 재작성
function incrementField(item, field) {
  return update(item, field, function(value) {
    return value + 1;
  })
}
```

최종적으로 만들어진 update함수는 특정 아이템이나 필드에 종속되지 않는 매우 일반적이고 재사용 가능한 추상화의 결과물임
이것이 추상화임

### 실 vs 레고
이 차이를 실과 레고에 비유할 수 있음

- 실:
  - 여러 가닥의 싫을 한데 엮는것은 매우 쉬움
  - 금방 뭉칠 수 있음
  - 하지만 실을 엮어서 튼튼한 집을 지을 수는 없음
  - 한번 엉키고 나면 다시 풀기가 거의 불가능에 가까움
  - 이것이 '쉬움'을 추구한 코드의 말로
  - 당장은 편하지만 구조적으로 취약하고 변경이 어려움
- 레고: (간결함)
  - 레고 블럭 하나를 만드는것을 실을 뭉치는것보다 복잡할 숭 ㅣㅆ음
  - 각 블록은 독립적이며 '블록'한 부분과 오ㅁ고한 부분이 맞물린다는 명확한 규약(인터페이스)를 통해 다른 블록과 연결됨
  - 이 간결한 모듈성을 통해 우리는 복잡하고 견고한 구조를 자유롭게 만들고 해체할 수 있음
코딩역시 눈앞의 문제를 해결할기 위해 쉽게 코드를 엮는 것이 아니라, 시간이 좀 더 걸리더라도 재사용 가능하고 독립적인 모듈을 만드는 것이 장기적으로 훨씬 더 확장 간으하고 유지보수하기 좋으 코드임

## 2. 캡슐화라는 사회성 필터: 똑똑하게 숨기는 기술

캡슐화를 통해 구체적인 형태를 만들어 나갈 차례임
캡슐화를 우리의 ㅇ뇌 활동에 비유하면 쉽게 이해가능

만양 우리의 모든 생가기여 여과없이 다른 사람에게 저달된다면 어덯게 될까?
아마
끔찍한 TMI 대참사가 잘것
다행히 우리 뇌는 숨낳은 생각을 내부에 캡슐화 하고 사회성 필터라는 정제돠정을 거쳐 입이라는 인터페이스를 통해 필요한 말만 밖으로 내보냄
덕분에 상대방은 대화의 핵심에만 집중가능

프로그램인도 이ㅣ와 같음
데이터와 그 데이터를 처리하는 로직을 하나의 캡슐로 묶고
내부의 복잡한 구현은 숨긴 채 외부에 꼭 필요한 인터체이스만 노출하는것
이를 통해 데이터의 무결성을 지키고 외부의 영향으로부터 코들르 안전하게 보호할 수 있음

잘 된 켭술화의 직접적인 결과는 높은 응집도임
응ㄷ집도란 한의 모듈이 얼마나 긴밀하게 연관된 기능들로 구성되는지 나타내는 척도
응집도가 높다는것은 해다 모듈이 한가지 ㅁ여확한 책임을 잘 수행하고 잇다는 의미 이며 이느 ㄴ코드의 재사용쇼ㅓㅇㅇ과 이해도를 극저으로 노ㅓㅍ여줌

예를 들어 API 호출 로직을 useState와 useEffect를 조합하여 구현하는것과 tanstackquery의 useQuery를 사요하는것으 비교해보자.

```js
// tanstackquery 높은 캡슐화와 응집도
const {data} = useQuery(key, fetcher)

// useState  +useEffect
const [data, setData] = useState();
useEffect(() => {
  fetch(/** */)
  // ...
}, [])
```

useQuery는 데이터 fetching에 필요한 상태관리, 로딩, 레어처리등의 복잡한 로직을 내부에 완벽히 캡슐롸하고, 개발자에게는 data라는 간결한 인터페이스만 제공함

반면 useState, useEffect를 사용한 방식은 데이터 상태와 비동기 로직이 코드 여러곳에 흩어져 있어 응집도가 낮고 재사용이 어려움

더 나아가 TodosController같은 패턴을 생각해볼 수 있을것
dd, search, filter등 Todo와 관련된 모든 로직을 하나의 체인 가능한 객체안에 캡슐화하는것
이를 통해 개발자느 TodosControllerㅇ 하나만으로 모든 Todo 관련 로직을 파악하고 사용할 수 있게 됨
TOdo라는 주제로ㅓ 간ㅇ하게 결합되어 있기 떄문에 관련없는 로직이 끼어들 틈이 없어 응집도는 극대화됨

## 3. '추상화 벽'와 '어댑터': 복잡한 리팩토링을 위한 안전장치

이제 마지막으로 거대한 코드 베이스를 안전하게 변경하는 실전 기술을 알아볼ㄷ것
예를 들어, 프로젝트에서 사용하던 Formik이라는 라이브러리를 react-hook-form으로 마이그레이션해야하느상황을 가정해봄
이럴 떄 필요한 것이 바로 추상화벽와 어댑터 패턴임

### 추상화 벽
코드의 서로 다른 추상화 레벨 사이에 벽을 세우는 것
예를 들어, '사용자에게 폼을 보여준다'는 고수준의 비즈니스 로직과 '특정 라이브러리를 사용해 상태를 관리하다'는 저수준의 구현로직을 분리하는것
이 벽 덕분에 저수준의 구현이 바뀌더라도 고수준의로직은 아무런 영향을 받지 않게 됨

### 어댑터
오환되지 않는 두 인터페이스를 연결해주는 중재자 역할을 함
마치 한국에서 사용하던 전자제품을 규격이 다른 유럽의 수켓에 연결해주는 돼지코처럼
어댑터는 양쪽의 규격을 모두 이해하고 중가에서 변확을 책임져, 사ㅓ로 다른 두 시스템이 함꼐 작동하도록 돕습니다.

이 두 개념을마이그레이션하는데 적용하늗 안전한 단계별 리팩토링 가능함

- 1단계: 경계 정의하기
  - UI 컴포넌트 로직와 폼 로직 사이의 인텊페이슬 명확히 하고 그대로 유지함
  - 컴포넌트 내부에서 formik을 쓰던, react-hook-form을 쓰던 알 필ㄹ요 없음
- 2 단계: 어댐=ㅂ터로 ㅕㄱㄱ리하기
  - useOrganizationForm, usePermissionForm등 여러 폼으 가갖의 폼을 위하 어댑터 역항르 하도록만듬
  - useFormik과 같은 라이브러리 호출 코드를 이 어댑터 훅들 대부로 숨겨, 외부에서는 라비ㅡ로ㅓ 존재를 알수 없게 함
- 3단계: 점진적 교체
  - 이제 어댑터 훅 내부의 userFromi구현을 rewact-hook-form으로 고ㅛ체함
  - 어댑터의 외부 인터페이슨 변하지 ㅇ낳기에, 이관정ㅇ서ㅔ 애플리케이셔으니 다른 부분을 수정하 필ㄹ요없음

## 결론
좋은 코드를 만드는 것은 단순히 코드를 짧게 나누는 행위가 아닙니다. 그것은 생각의 전환을 요구하는 깊이 있는 과정입니다.
1. 단순한 코드 추출을 넘어, 코드의 본질을 꿰뚫는 추상화를 추구해야 합니다.
2. 복잡한 내부는 감추고 명확한 인터페이스만 드러내는 캡슐화를 통해 응집도 높은 모듈을 만들어야 합니다.
3. 대규모 변경이 필요할 땐 추상화 벽과 어댑터를 활용해 리스크를 최소화하고 안전하게 나아가야 합니다.

이 세 가지 생각의 전환은 여러분의 코드를 한 차원 높은 수준으로 이끌어 줄 것입니다.
오늘 살펴본 개념들 중, 지금 당장 여러분의 코드 베이스에 가장 적용하고 싶은 것은 무엇인가요?
