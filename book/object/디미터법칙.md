## 묻지 말고 시켜라.

디미터의 법칙을 통해 요구사항 변경에 취약한 객체를 확인할 수 있다.
가령 아래 Theater의 enter 메서드는 디미터의 법칙을 위반한 코드이다.

```java
public class Theater {
  private TicketSeller ticketSeller;

  public Theater(TicketSeller ticketSeller) {
    this.ticketSeller = ticketSeller;
  }

  public void enter(Audience audience) {
    if(audience.getBag().hasInvitation()) {
      Ticket ticket = ticketSeller.getTicketOffice().getTicket();
      audience.getBag().setTicket(ticket)
    } else {
      Ticket ticket = ticketSeller.getTicketOffice().getTicket();
      audience.getBag().minusAmount(ticket.getFee())
      ticketSeller.getTicketOffice().plusAmount(ticket.getFee())
      audience.getBag().setTicket(ticket)
    }
  }
}
```
- 디미터 법칙에 따르면 Theater가 인자로 전달된 audience와 인스턴스 변수인 ticketSeller에게 메시지를 보내는것까진 문제가없다.
- 문제는  Theater 가 ticketOffice, bag등에 직접 접근함이 문제가 된다.
- `audience.getBag().minusAmount(ticket.getFee())`가 전형적인 지차 충돌 스타일의 모습이며 디미터 법칙을 위배한 경우다.
- Theater는 Bag에게도 메시지를 전송하기 떄문에 Theater는 Audience의 퍼블릭 인터페이스 뿐만 아니라 내부 구조에 대해서도 결합된다.
- 근본적으로 디미터 법칙을 위반하는 걸계는 인터페이스와 구현의 분리 원칙을 위반한다.
- 기억해야할 점은 객체의 내부 구조는 구현에 해당한다는 것이다.
- Audience가 Bag를 포함한다는 사실은 Audience의 내부 구현에 속하며, Audience는 자신의 내부 구현을 자유롭게 변경할 수 있어야 한다.
- 그러나 퍼블릭인터페이스에 getBag()를 포함시키는 순각 객체의 구현이 퍼블릭 이턴페이스를 통해 외부로 새어나가고 말고
- 이는 Audience의 내부 구현의 자유도를 제한하고 이는 변경의 취약해진다.
- 뿐만 아니라, 사용하기도 어렵다.
- 클라이언트 객체의 개발자는 Audience의 퍼블릭 인터페이스 뿐만 아니라, Audience의 내부 구조까지 속속들이 알고 있어야 하기 떄문이다.
- 디미터 법칙을 위반한 코드를 수정하는 일반적인 방법은 Audience와 TicketSeller의 내부 구조를 묻는 대신 Audience와 TicketSeller가 직접 자신의 책임을 수행하도록 시키는 것.


- Theater는 TicketSeller와 Audience의 내부 구조에 관해 묻지 말고 원하는 작업을 시켜야한다.
- TicketSeller와 Audience는 묻지 말고 시켜라 스타일을 따르는 퍼블릭 인터페이스를 가져야하낟.
- 먼저 Theater가 ticketSeller에게 자신이 원하는 일을 시키도록 수정하자.
- Theater가 TicketSeller에게 시키고 싶은 일은 Audience가 Ticket을 가지도록 만드는 것이다.
- TicketSeller에 setTicket 메서드를 추가하고 enter 메서드의 로직을 setTicket 메서드 안으로 옮기자.
```java
public class TicketSeller {
  public void setTicket(Audience audience) {
    if(audience.getBag().hasInvitation()) {
      Ticket ticket = ticketOffice.getTicket();
      audience.getBag().setTicket(ticket)
    } else {
      Ticket ticket = ticketOffice.getTicket();
      audience.getBag().minusAmount(ticket.getFee())
      ticketOffice.plusAmount(ticket.getFee())
      audience.getBag().setTicket(ticket)
    }
  }
}
```
- Theater는 자신의 속성으로 포함하고 있느 TicketSeller의 인스턴스에게만 메시지를 전송하게 됐다.
```java
public class Theater {
  public void enter(Audience audience){
    ticketSeller.setTIcket(audience)
  }
}
```

- 이제 TicketSeller에 초점을 맞추자.
- TicketSeller가 우너하는 것은 Audience가 Ticket을 보유하도록 만드는것이다.
- 따라서 Audience에게 setTIcket 메서드를 추가하고 스스로 티켓을 가지도록 만들자.

```java
public class Audience {
  public Long setTicket(Ticket ticket) {
    if(bag.hasInvitaion()) {
      bag.setTicket(ticket)
      return 0L;
    } else {
      bag.setTicket(ticket)
      bag.miinusAMount(ticket.getFee())
      return thicket.getFee()
    }
  }
}
```
- 이제 TicketSeller는 속성으로 포함하고 있는 TicketOffice의 인스턴스와 ㅇ니자로 전달된 Audience에게만 메시지를 전송한다.
```java
public class TicketSeller {
  public void setTicket(Audience audience) {
    ticketOffice.plusAmount(
      audience.setTicket(ticketOffice.getTicket())
    )
  }
}
```
- 문제는 Audience다. Audience의 setTicket메서드르 자세히 살펴보면, Audience가 Bag에게 원하는 일을 시키기 전에 hasInvitation메서드를 이용해 초대권을 가지고 있는지 묻는다.
- 따라서 Audience는 디미터 법칙을 위반한다.
- Audience의 setTicket메서드 구현을 Bag로 이동시키자.
```java
public class Bag {
  public Long setTicket(Ticket ticket) {
    if(hasInvitation()) {
      this.ticket = ticket;
      return 0L;
    } else {
      this.ticket = ticket;
      minusAmount(ticket.getFee())
      return ticket.getFee()
    }
  }

  private boolean hasInvitation() {
    return invitation != null;
  }

  private void minusAmount(Long amount) {
    this.amount -= amount;
  }
}
```
- Audience의 setTicket메서드가 Bag의 setTicket메서드를 호출하도록 수정하면 묻지말고 시켜라 스타일을 따르고 
- 디미터 법칙을 준수하는 Audience를 얻을 수 있다.
```java
public class Audience {
  public Long setTicket(Ticket ticket) {
    return bag.setTicket(ticket);
  }
}
```
- 디미터 법치과 묻지 말고 시켜라 원칙을 따라 ㅋ드를 리팩토링 한 후 Audience가 스스로 자신의 상태를 제어하게 됐다는 점에 주목하라.
- Audience는 자신의 상태를 스스로 관리하고 결정하는 자율적인 존재가 된 것이다.


---

- 지금까지 갈펴본 것처럼 디미터 법칙과 묻지말고 시켜라 스타일을 ㄸ르면 자연스럽게 자율적인 객체로 구성된 유연한 협력을 억데 된다.
- 구현이 객체의 퍼블릭 인터페이스에 노출되지 않기 떄문에 객체 사이의 결합도는 낮아진다.
- 책임이 잘못된 곳에 할당될 가능성이 낮아지기 때문에 객체의 응집도 역시 높아진다.
- 이제 이런 인터페이스를 얻었다면 
- 인터페이스가 클라이언트의 의도를 올바르게 반영했는지를 확인해야 한다.