코드 중복의 관점

- 재거하는게 아니라 발견되는 것
- 여기까지가 중복이 아니라 판단했다가 큰 범
- 중복이 보다보니, 개발할게 아니다.
- 자기 수준에 따라 보인다
- 실무에서는 리버스 드라이라고해서
- 중복이 아닌 경우가 대부분이다.

- 코드는 시간에 따라 변화함
- 최초 작성시에는 이후 변화를 예측할 수 없다.
- 최소 집합으로 코드를 작성하다보니, 얘네가 비슷비슷하게 보여
- 하는 일이 조금밖에 없는데? 중복될 확율이 높아짐
- 이게 미래에 전개되다보면 달라질 수 있다. 전혀 다른 코드일 수 있다.
- 초반에 중복을 제거하면, 분리해야하는데 괴물이 되어있음
- if분기나 flag분기를 덕지덕지 하다가 분리하려보면 엄청 힘듬
- 계속 다달라 짐, 게시판 이라도
- 어떻게든 type으로 버텨볼려했지만
- 한계를 넘는 이상한 형태가 나와서 감당할 수 없는것
- ==코드 중복, DRY가 나쁜거 아닌데, 초반에 판정하면 안된다는것==

확실히 독립적인건 중복제거해도 되

- 비 도메인 적 기능
- 순수 기능적 이런건 빼도 돼, 중복을 제거해도 돼
- front개발해, log를 직어 프러덕션에선 console.log가
- 나만의 로그함수를 만들어서 찍기 시작해
- 그게 로그가 순수기능으로 생각되니까, 대문자 로그는 이 함수르 써야해 했다.
- 나중에 보니까, console.promt, console.error쓰고 있었음
- 사내에서 쓸떄는 도메인적이다.
- 그래서 애매할 수 있다.

상속

- 부모: final public기능구현과 abstract protected훅만 사용
- 자식: 오직 훅만 구현
- 대부분의 상속 관련 문제를 해결함
- 조합폭발은 해결불가
  합성
- 조합폭팔이 일어날 가능성이 있으면 이거 쓰셈
- 쓸데없느 ㄴ구현 위임 코드 생성(코틀린 인터페이스 위임 편리)
- 합성할 꺼면 코틀린 써랑
- 위임객체를 외부에서 주입 편리
- 합성을 쓰면, 합성할 실체 객체가 있고, 위임함 ㄹ컨테이너 객체가있다.
- 합성이란 그런건데, 밖에서 주입하면 되니까 편한데
- 저략객체하고 소유한 객체사이의 통신은 어떻게 해야할까
- 전략객체가 레퍼의 어디까지 알고잇고 파거들어야하나
- 레퍼에 아무런 속성을 안쓸건데 왜 래퍼 써?
- 래퍼가 전략패턴 짝짝궁해서 어디까지 알아야한다는거야?
- 의존성을 많이 갖게 된 래퍼는
- 합성을 소유한 객체와 의 관계,
- 합성은 사람들이 써놓은 코드는 뭐? 미디에이터? 지넞ㅇ한 의미에서 유기적인 합성은 쉽지 않다.
