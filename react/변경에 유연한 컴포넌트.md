방금 완성한 긴응에 변경이 발생한것
변경이라는 단어에 피로감을 느끼기 쉽다.
하지만 변경은 문제가 아니라, 우리가 아직 발견하지 못했도ㅓㄴ 고객의 니즈를 찾아가는과정임

변경은 예측하는 것이 아니라 대응하는것이다.

이 글은, 예측할 수 없는 변경의 파도 속에서 표류하지 않고 오히려 변화를 동ㄹ력 삼아 더 빠르고 견고하게 나아갈 수 잇는 컴포넌트 설계 철학을 이야기함
왜 변경이 고통스러운지 원인을 진단하고
이를 해결하기 위한 세가지 설계 원칙과 당장 실천할 수 있는 2가지 생동방안을 살펴볼것

## 1. 우리는 왜 변경에 고통받는가: 적당히 분리된 컴포넌트의 함정

우리는 경험적으로 코드가 한곳에 뭉쳐있으면 파악하기 어렵다느 사실을 암
그래서 기능이 커지면 자연스럽게 컴포넌트를 분리함
하지만 여기서 적당히 라는 모호한 기준이 발목을 잡음
명화한 원칙 없이 단순히 파일 크기가 커졌다는 이유로, 혹은 어제는 중복 코드로 보였다는 이유로
컴포넌틑 나누다 보면 유지보수의 앇목이 시작됨

변경 대응을 힘들게 만드는 진짜 원인은 바로 이 기준없는 분리에 있음

```tsx
<Item item={item} />
```

Item 이라는 이름의 컴포넌트가 item이라는 프롭을 받고 있다.
이 코드만 보고 어떤 데이터를 다루는지,
그 데이터를 화면에 어떻게 보여주는지 유추할 수 있는 사람이 있을까?
아이템이 아이템이라니 저조차도 당시 무슨 생각으로 이런 코드르 작성했는지 파악하기 어렵다.

이런 쿄ㅗ드는 대게 이런 과정을 거쳐 탄행함
처음에는 하나의 거대한 페이지 컴포넌트였지만,
코드가 길어지고 복잡해지자 적당히 덜어내는 과정ㅇ에서 Item이라는 이름으로 분리되엉ㅆ을 것

이러한 모호함은 단순히 기술 부채를 만드는데 그치지 ㅇ낳고, 우리 개발 사이클에 예측 불가능성을 주입함
간단한 기능 요청이 프로젝트 전반의 리팩토링으로 비화될 수 있으며, 이는 고객에게 가치를 전달하는 속도에 직접적인 영향을 미침

문제는 변경이 많다는 사실 자체가 아님
진짜 문제는 변경에 취약한 컴포넌트 구조임
따락서 우리는 적당히 라는 감에 의존하는 대신,, 변경에 효과적으로 대응할 수 있는 명확한 설계 원칙을 세워야함

## 2. 변경에 유연한 컴포넌트 만드는 3가지 원칙

변경에 유여한 컴포넌트는 코드의 재사용성과 확정성을 극대화하여 제품의 지속가능한 성장을 뒷받침함

이를 위한 3가지 핵심원칙은 하나의 완전한 설계 전략을 이룸

우리는 컴포넌트의 내부 구조부터 외부 인페이스에 이르기까지 점진적으로 접근할것

1. 먼저 컴포넌트 내부의 솬심사를 분리하고(헤드리스 추상화)
2. 이어서 컴포넌트들이 서로 어떻게 상호작용할지 정의하며(조합)
3. 마지막으로 컴포넌트가 더 넓은 애플리케이션과 어떻게 소통할지 결정할것(도메인 레이어링)

이 원칙들이 어떻게 상호작용하며 견고한 구조를 만드는지 하나씩 볼것

### 2.1 헤드리스 추상화- 로직과 UI를 분리

일반적으로 컴포넌트는 세가지 역할을 수행함

1. 데이터 관리: 외부에서 주입받거나 내부적으로 상태를 관리함
2. UI: 관리하는 데이터를 사용자에게 어떻게 보여줄지 정의함
3. 상호작용: 사용자의 입렵에 어떻게 반응할지 정의함

헤드리스 추상화는 이 세가지 역할 중 데이터 관리와 상호작용에 따른 로직을 UI로 부터 완전히 분리하는 설계 패턴임

데이터 추상화: useCalendar예시
달력 컴포넌트를 만든다고 상상해보자.
달력의 디자인은 언제든 바뀔 수 있지만, 특정 월의 날짜를 2차원 배열로 계싼하는 핵심 로직은 변하지 ㅇ낳음
이 로직을 UI와 분리해보겟슴

```tsx
// 달력의 데이터 로직을 관리하는 HEadless Hook
const { weeks, currentDate } = useCalendar();
```

useCalendar라는 커스텀 푹은 달력의 핵심 데이터와 상태를 계산하고 관리하느 역할만 담당함
이 훅은 비즈니스 로직을 프레젠테이션 레이어로부터 분리하여,
일시적인 디자인 변경으로부터 핵심 기능을 보호하는 견고한 경계를 만듬

```tsx
function TableCalendar() {
  const { week } = useCalendar();

  return <table></table>;
}
```

이제 전혀 다른 디자인의 달력이 필요해져도, 우리는 useCalendar훅을 재사용하여 UI 구현에만 집중할 수 있음

상호작용 추상화: useLogPress예시
이번에는 상호작용 로직을 분리해보겠음
특정 버튼에 '길게 누르기'기능을 추가해야한다고 가정해보자.
mousedown, mouseup, setTimeout 등 여러 이벤트를 조합해야하는 복잡한 로직이 컴포넌트 내부에 들어오면
코드의 책임이 모호해짐

```tsx
// 롱 프레스 상호작용 로직을 관리하는 Headless Hook
const logPressProps = useLongPress(() => {
    console.log('Long Press')
})


<Button {...longPressProps} >길게 누르세요</Button>
```

useLogPress 훅을 사용하면 상호작용 로직 전체가 훅 내부로 캡슐화됩니다.
버튼 컴포넌트는 useLongPress가 반환하는 프롭들을 그저 UI에 적용하기만 하면됨
이제 버튼 컴포넌트는 어떻게 보여질지에만 집중할 수 있고 롱 프레스 기능은 다른 어떤 컴포넌트에도 쉽게 재사요ㅕㅇ가능

헤드리스 추상화의 핵심가치는
각 모듈이 한가지 문제에만 집중하게 만드는것

이를 통해 재사용성을 극대화하고, 다른 부분의 견경으로부터 로직을 안전하게 격리시킬 수 있음

### 2.2 조합 - 한 가지 역할만 하는 컴포넌트들의 합주

복잡한 컴포넌트를 하나의 거대한 덩러리로 만들면 변경에 매우 취야ㅐㄱ해짐
대신 단일 책임을 가진 작은 컴포넌트들의 조합으로 기능을 완성해야함
조합의 힘은 단일 책임 원칙을 엄격하게 준수할 댸 발휘함
Dropdown.Trigger, Dropdown.Menu와 같은 각 컴포넌트는 변경되어야할 이유가 단 하나뿐이며
이는 모든 수정의 영향 범위를 최소화하는 열쇠임

흔히 볼 수 있는 SelectUI컴포넌트를 통해 조합의 힘을 보겠음

- Before: 변경에 취약한 단일 컴포넌트
- 이 컴포넌트는 ReactFramework라는 특정 목적을 위해 라벨과 버튼이 내분에 하드코디되어있슴
- 라벨만 바꾸려고 해도 프롭을 추가하고 내부 코드를 수정해야함
- 다른 버튼 UI를 사용하고 싶다면 문제는 더 복잡해짐

- After: 조합 가능한 컴포넌트들의 합주.
- 이 컴포넌트를 역할에 따라 잘게 쪼개어 재구성해보자.
  - Dropdown: 메듀의 열림/닫힘 상태를 관림
  - Dropdown.Trigger: 메뉴를 열고 닫는 상호작용을 담당함
  - Dropdown.Menu: 옵션 목록을 담는 컨테이너 역할을 함
  - Dropdown.Item: 각 옵션 항목과 선택 이벤트를 처리함
- 이제 이 작은 컴포넌트들을 조합하여 SelectUI를 다시 만들어보겠음

- 여기서 핵심적인 설계는 제어의 역전임
- 상위 Dropdown 컴포넌트는 상태와 로직을 제공하지만
- 트리거가 InputButton인지 일반 button인지는 전혀 알지 못함
- 하위 컴포넌트들은 UI와 구체적인 행위를 제공함
- 이처럼 각 컴포넌트가 서로의 존재를 모그고 각자의 역할에만 충실하기에
- InputButton의 디자인이 어떻게 바뀌든 Dropdown 로직에는 아무런 영향이 없음
- 변경의 영향범위가 최소화되고 재사용성으 극대화 됨

### 심화사례: 복잡한 UI도 조합으로 해결하기

겉보기에 복잡한 UI도 데이터 흐름의 관점에서 보면 단순하 구조의 변형이 ㄹ뿐인 경우가 많다.
버튼을 누르면 모달이 뜨고, 여러 항목을 체크한 후 저굥ㅇ하기를 누르면 버튼에 선택된 값들이 표시되는 UI를 생각해보자.

이 UI는 복잡해조이지만, 본질은 "옵션을 제공하고 선택된 값을 보여주는" Select UI와 데이터 흐름이 동일함
여러개를 서택할 수 있다는 점만 다르뿐

따라서 앞서 만든 Dropdown 컴포넌트 조합을 활용하여 다음고 같이 새로운 조합을 만들 수 있음

```tsx
<Dropdown>
  <Dropdown.Trigger>
    <Button>프레임워크 선택</Button>
  </Dropdown.Trigger>

  {/* 메뉴 대신 모달을 띄우는 새로운 조합 */}
  <Dropdown.Modal>{/* 체크박스 목록과 적용/취소 버튼 */}</Dropdown.Modal>
</Dropdown>
```

이처럼 컴포넌트를 레고 블록처럼 조합 가능하게 설계하며ㅑㄴ
아무리 복잡한 요구사항이 들어와도 기존 블록들을 재조립하여 빠르고 유요ㅕㄴ하게 대응할 수 있음

### 2.3 도메인 레이어링 - 비즈니스 로직과 순수 UI 의 분리

방금 만든 FrameworkSelect 컴포넌트는 휼륭하지만, '프레임워크 선택'이라는 특정 도메인에 종송되어있음
만약 은행 선택 UI가 필요하다면 이 컴포넌트 재사용힘듬
ㅇ8ㅕ기서 도메인 분리의 필요성이 대두됨

도메인 분리하는 과정은 컴포넌트의 이름과 프롭에서 특정 비즈니스 맥락을 제거하는것에서 시작됨

- FrameworkSelect -> MultiSelect
- selectedFrameworks -> value
- onFrameworkChange -> onChange

이렇게 도메인 맥락을 걷어내다 보면, 컴포넌트의 인터페이스는 자연스럽게 HTML의 select태그 처럼 일반적이 ㄴ용어로 구성됨

이것이 왜 중요할까?
우리는 value와 onChange같은 API를 통해 수년간 축적된 웹 개발의 공동 지식을 활용할 수 있음
이는 우리 컴포넌트를 사용하는 개발자의 인지 부하를 극적으로ㅓ 줄요ㅕ줌
개발자는 독자적인 API를 배울 필요 없이
기존의 정신 모델에 읜종하여 컴포넌트의 동작을 쉽게 예측하고 이해할 수 있음
우리 컴포넌트라이브러리가 플랫폼 자체의 자연스러운 확장처럼 느껴지게 만드는것

컴포넌트 인퍼테이스 표준에 가까울수록 많은 사람들이 쉽게 이해할 수 있다.

최종적으로 컴포넌트의 역할은 2개의 레이어로 명확하게 분리됨

### 1. 순수 UI 컴포넌트

- 도메인을 전혀 모름
- value와 onChange같은 일반적인 인터페이스를 통해 데이터만 중비받아 화면에 그리는 역할에 충실함
- 어던 비즈니스 맥락에서든 재사용 가능

### 2. 도메인 포함 컴포넌트 (FrameworkSelect)

- 프레임워크라는 도메인을암
- API를 호출하여 프레임워크 목록을 가져오는 등 비즈니스로직을 처리함
- 가져온 데이터를 순수UI 컴포넌트인 MultiSelect에 전달하여 화면을 그리도록 위임함

이처럼 역하을 분리하면, 비즈니스 로직의 변경이 순수 UI에 영향을 주지 ㅇ낳고, UI 디자인의 변경또한 비즈니스 로직에 영얗ㅇ을 주지 ㅇ낳는
견곡한 구조가 됨

## 3. 지금 바로 시작할 수 있느 2가지 실천법

### 3.1 인터페이스 먼저 설계하기(API First)

컴포넌트의 내부 로직을 구현하기 전에, 그 컴포넌트가 이미 완성되었다고 가정하고 사용하느 입장의 코드를 먼저 ㄱ작성해보는것

예를 들어 은행 목록과 선택된 은행 폼 UI를 만들어야한다고 해보자.
여기서 결정적인 통찰은 시각적 레이아웃을 무시하고 상태관리에 집중하는 것
이 시스템은 다음 3가지를 알아야함

1. 사용 가능한 옵션 목록
2. 현재 선택된 옵션
3. 선택을 업데이트 하는 방법
   이는 기능적으로 select와 동일함

이 통찰을 바탕으로 가상의 Select 컴포넌트를 사용해 코드를 먼저 작성해보자.

```tsx
<Select
  value={selectedBank}
  onChange={setSelectedBank}
  // 선택된 값을 어떻게 렌더링할지 함수 (render prop)로 전달
  renderValue={(bank) => <BankForm bank={bank} />}
>
  <BankList onSelect={} />
</Select>
```

이렇게 사용하는 코드를 먼저 작성하면 우리가 만들 Select컴포넌트에 어떤 프롭이 필요한지 자연스럽게 도출됨
이 방법은 다 만들고 나서 상7ㅛㅇ하려니 의도 파악하기 어렵고 불현했던 무넺를 근본적으로 ㄷ예방하고 처음부터 개발자 친화적인 API 를 설계하도록 도움

### 3.2 분리하기전에 왜라고 질문하기

습관적으로 컴포넌트를 나누기 전에 잠시 멈추고 스스로에게 질문하는 습관을 들이는것이 중요

지금 내가 이 컴포넌트를 분리하려는 이유가 무엇인가
단순히 코드가 기러져서 복잡도를 낮추기 위함인가
아니면 다른 곳에서도 쓸 수 있도록 재사용하기 위하인가

이 간단한 실문은 무분별하고 비용이 많이 드는 추상화를 막아줌
두 동기는 서로 다른 설계 노력을 요구함

- 복잡도는 낮추기 위함: 이는 로컬 코드의명확성과 유지 보수성에 관한 것
  - 해당 컴포넌트는 다시는 재사용되지 ㅇ낳을 수도 있지만, 분리를 통해 부모 컴포넌트를 더 쉽게 이해할 수 있게되ㅏㅁ
  - 이는 비교적 간닿나 로컬 리팩토링임
- 재사용하기 위함ㅣ
  - 이는 훨씬 더 높은 수준의 설계 노려력을 피료함
  - 도메인 레이어링 원칙에서 논의했듯
  - 도메인에 구애받지 않는 일반적인 API를 만들어야함
  - 이느 ㄴ비용이 더 많이 들지만
  - 잠재ㅔ적으로 더 큰 가치를 창출하는 의도적인 추상화 과정임

이 질문은 우리에게 2가지 길 사이에서 의식적이 ㄴ선택을 하도록 강제하여,
각 컴포넌트의 목적을 명확히 하고 꼭 필요한 분리만 수행하도돕움

## 4. 좋은 컴포넌트는 비즈니스의 기초 체력임
